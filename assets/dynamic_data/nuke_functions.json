[
    {
        "name": "AColor_Knob",
        "type": "Function",
        "doc": "AColor_Knob"
    },
    {
        "name": "AnimationCurve",
        "type": "Function",
        "doc": "AnimationCurve"
    },
    {
        "name": "AnimationKey",
        "type": "Function",
        "doc": "A control point for an animation curve.\n@var x\nThe horizontal position of the point\n@var y\nThe vertical position of the point\n@var lslope\nThe derivative to the left of the point. If interpolation does not have\nUSER_SET_SLOPE then this may not be correct until after evaluate() has been\ncalled.\n@var rslope\nThe derivative to the right of the point. If interpolation does not have\nUSER_SET_SLOPE then this may not be correct until after evaluate() has been\ncalled.\n@var la\nThe left 'bicubic' value. This represents the horizontal\nposition of the left bezier handle end, where 1.0 means 1/3 of the\ndistance to the previous point. If both handles for a span are 1.0\nthen the horizontal interpolation is linear and thus the vertical\ninterpolation a cubic function.  The legal values are 0 to\n3. Setting outside of this range will produce undefined results.\n@var ra\nThe right 'bicubic' value, again the legal range is 0 to 3.\n@var interpolation\nUsed to calculate all the slopes except for the left slope of the first key\nand the right slope of the last key.\nLegal values are:\n- USER_SET_SLOPE: If this bit is on, the slopes are fixed by\n                  the user and interpolation and extrapolation are ignored.\n- CONSTANT: The value of the curve is equal to the y of the\n            point to the left.\n- LINEAR: slopes point directly at the next key.\n- SMOOTH: same as CATMULL_ROM but the slopes are clamped so that the\n          convex-hull property is preserved (meaning no part of the curve\n          extends vertically outside the range of the keys on each side of\n          it). This is the default.\n- CATMULL_ROM: the slope at key n is set to the slope between the control\n               points n-1 and n+1. This is used by lots of software.\n- cubic: the slope is calculated to the only cubic interpolation which makes\n         the first and second derivatives continuous. This type of\n         interpolation was very popular in older animation software.  A\n         different cubic interpolation is figured out for each set of adjacent\n         points with the CUBIC type.\n- for the smooth, CATMULL_ROM, and CUBIC interpolations, the first and last\n  key have slopes calculated so that the second derivative is zero at them.\n@var extrapolation\ncontrols how to set the left slope of the first point and the right slope of\nthe last point. Notice that this can be set differently on the first and last\npoints, and is also remembered on all internal points so if end points are\ndeleted old behavior is restored).\n- constant: the left slope of the first point, and the right slope of the last\n            point, are set to zero.\n- linear: (and all other values): The left slope of the first point is set\n          equal to it's right slope (calculated by the interpolation).\nthe right slope of the last point is set equal to it's left slope.\nif there is only one point both slopes are set to zero.\n@var selected\nTrue if the point is selected in the curve editor."
    },
    {
        "name": "Array_Knob",
        "type": "Function",
        "doc": "A knob which holds an array of values."
    },
    {
        "name": "Axis_Knob",
        "type": "Function",
        "doc": "A knob which descibes a 3D affine transformation, by combining rotations around each principal axis, scaling, translation, skew and a pivot point."
    },
    {
        "name": "BBox_Knob",
        "type": "Function",
        "doc": "A knob which holds a bounding box."
    },
    {
        "name": "BackdropNode",
        "type": "Function",
        "doc": "No documentation available."
    },
    {
        "name": "BeginTabGroup_Knob",
        "type": "Function",
        "doc": "Begin a group of tabs. Subsequent knobs will all be part of the same tab group, until a matching EndTabGroup knob is found."
    },
    {
        "name": "Bitmask_Knob",
        "type": "Function",
        "doc": "Bitmask_Knob"
    },
    {
        "name": "Boolean_Knob",
        "type": "Function",
        "doc": "A knob which holds a boolean value. This appears in a Node panel as a check box."
    },
    {
        "name": "Box",
        "type": "Function",
        "doc": "A 2-dimensional rectangle. Described by left, right, top and bottom coords (width and height are calculated as necessary)."
    },
    {
        "name": "Box3_Knob",
        "type": "Function",
        "doc": "A 3-dimensional box."
    },
    {
        "name": "CancelledError",
        "type": "Function",
        "doc": "No documentation available."
    },
    {
        "name": "CascadingEnumeration_Knob",
        "type": "Function",
        "doc": "Stores a single value between 0 and some maximum, and manages a\nset of keywords visible to the user. The words themselves are\ndisplayed on a pulldown list in the user interface, and are written\nto the saved scripts (so that the numerical values can change). To \ncreate cascading submenus simply use the forward slash ( '/' ) \ne.g. menu/item1self.__init__(name, label, items) -> None\n@param name: Name.\n@param label: Label.\n@param items: List of strings.\nExample:\nk = nuke.Enumeration_Knob('MyEnumKnobName', 'MyEnumKnobLabel', ['menu1/label1', 'label2'])\n"
    },
    {
        "name": "ChannelMask_Knob",
        "type": "Function",
        "doc": "ChannelMask_Knob"
    },
    {
        "name": "Channel_Knob",
        "type": "Function",
        "doc": "A knob which lets you select a layer and enable or disable individual channels.\nself.__init__(s, label, depth) -> None\nConstructor.\n@param s: name.\n@param label: Optional name to appear in GUI. Defaults to the knob's name.\n@param depth: Optional number of channels with zero being the Nuke default number of channels. Defaults to 0.\n"
    },
    {
        "name": "ColorChip_Knob",
        "type": "Function",
        "doc": "A knob which holds a single unsigned int that describes a user interface colour. The color format is 0xRRGGBB00."
    },
    {
        "name": "Color_Knob",
        "type": "Function",
        "doc": "A knob which holds a color. Provides a UI for picking colours as well as editing the values directly."
    },
    {
        "name": "ColorspaceLookupError",
        "type": "Function",
        "doc": " an excpetion that should be thrown when looking up the colorspace "
    },
    {
        "name": "Disable_Knob",
        "type": "Function",
        "doc": "A knob which holds a boolean value representing the disabled state of a node. This appears in a Node panel as a check box."
    },
    {
        "name": "Double_Knob",
        "type": "Function",
        "doc": "A knob which holds one or more double-precision floating point values."
    },
    {
        "name": "EditableEnumeration_Knob",
        "type": "Function",
        "doc": "Stores a single value between 0 and some maximum, and manages a\nset of Radio Buttons visible to the user. This is essentially an\nEnumeration_Knob with a different widget."
    },
    {
        "name": "EndTabGroup_Knob",
        "type": "Function",
        "doc": "End a group of tabs. This is only valid when a BeginTabGroup knob has already been used."
    },
    {
        "name": "Enumeration_Knob",
        "type": "Function",
        "doc": "Stores a single value between 0 and some maximum, and manages a\nset of keywords visible to the user. The words themselves are\ndisplayed on a pulldown list in the user interface, and are written\nto the saved scripts (so that the numerical values can change).\nself.__init__(name, label, items) -> None\n@param name: Name.\n@param label: Label.\n@param items: List of strings.\nExample:\nk = nuke.Enumeration_Knob('MyEnumKnobName', 'MyEnumKnobLabel', ['label1', 'label2'])\n"
    },
    {
        "name": "EvalString_Knob",
        "type": "Function",
        "doc": "A string-valued knob which evaluates its value as a TCL expression."
    },
    {
        "name": "Eyedropper_Knob",
        "type": "Function",
        "doc": "Eyedropper_Knob"
    },
    {
        "name": "File_Knob",
        "type": "Function",
        "doc": "A knob which holds a filename. When it appears in a Node panel it provides a text field to show the filename and a button which opens the file chooser dialog."
    },
    {
        "name": "FnPySingleton",
        "type": "Function",
        "doc": "No documentation available."
    },
    {
        "name": "Font_Knob",
        "type": "Function",
        "doc": "A knob for choosing a font."
    },
    {
        "name": "Format",
        "type": "Function",
        "doc": "A format."
    },
    {
        "name": "Format_Knob",
        "type": "Function",
        "doc": "Format_Knob"
    },
    {
        "name": "FrameRange",
        "type": "Function",
        "doc": "A frame range, with an upper and lower bound and an increment."
    },
    {
        "name": "FrameRanges",
        "type": "Function",
        "doc": "A sequence of FrameRange objects with convenience functions for iterating over all frames in all ranges."
    },
    {
        "name": "FreeType_Knob",
        "type": "Function",
        "doc": "A knob which holds a font family and style name."
    },
    {
        "name": "GeoSelect_Knob",
        "type": "Function",
        "doc": "A knob which allows selection of parts of a 3D object."
    },
    {
        "name": "GeoSelection",
        "type": "Function",
        "doc": "No documentation available."
    },
    {
        "name": "GeoSelectionItem",
        "type": "Function",
        "doc": "No documentation available."
    },
    {
        "name": "Gizmo",
        "type": "Function",
        "doc": "No documentation available."
    },
    {
        "name": "GlobalsEnvironment",
        "type": "Function",
        "doc": "Dictionary-style object holding global Nuke state.\nExample:\nnuke.env['threads'] = 4"
    },
    {
        "name": "Group",
        "type": "Function",
        "doc": "No documentation available."
    },
    {
        "name": "Hash",
        "type": "Function",
        "doc": "A hash value for any number of objects.\n\nThe append() method is used to add objects to the hash; the value will be recomputed efficiently as each new object is added."
    },
    {
        "name": "Help_Knob",
        "type": "Function",
        "doc": "Help_Knob"
    },
    {
        "name": "Histogram_Knob",
        "type": "Function",
        "doc": "Histogram_Knob"
    },
    {
        "name": "IArray_Knob",
        "type": "Function",
        "doc": "IArray_Knob"
    },
    {
        "name": "Info",
        "type": "Function",
        "doc": "An info object stores x, y, w and h values."
    },
    {
        "name": "Int_Knob",
        "type": "Function",
        "doc": "A knob which holds one or more integer values."
    },
    {
        "name": "Keyer_Knob",
        "type": "Function",
        "doc": "Keyer_Knob"
    },
    {
        "name": "Knob",
        "type": "Function",
        "doc": "A modifiable control that appears (unless hidden) in the panel for a node.\nThis is a base class that specific knob types inherit from.\n\nKnobs can be animated, have expressions, be disabled or hidden and more."
    },
    {
        "name": "KnobType",
        "type": "Function",
        "doc": "Constants for use in parameters which require a knob type."
    },
    {
        "name": "Layer",
        "type": "Function",
        "doc": "A layer is a set of channels."
    },
    {
        "name": "Link_Knob",
        "type": "Function",
        "doc": "Link_Knob"
    },
    {
        "name": "LinkableKnobInfo",
        "type": "Function",
        "doc": "A linkable knob description. Holds a reference to a knob that may be linked to, as well as an indication whether this knob should be used as part of an absolute or relative expression and whether it is enabled.\n"
    },
    {
        "name": "LiveGroup",
        "type": "Function",
        "doc": "No documentation available."
    },
    {
        "name": "LookupCurves_Knob",
        "type": "Function",
        "doc": "Provide a set of user-editable lookup curves."
    },
    {
        "name": "Lut",
        "type": "Function",
        "doc": "Lut"
    },
    {
        "name": "Menu",
        "type": "Function",
        "doc": "Menu"
    },
    {
        "name": "MenuBar",
        "type": "Function",
        "doc": "MenuBar"
    },
    {
        "name": "MenuItem",
        "type": "Function",
        "doc": "MenuItem"
    },
    {
        "name": "MultiView_Knob",
        "type": "Function",
        "doc": "MultiView_Knob"
    },
    {
        "name": "Multiline_Eval_String_Knob",
        "type": "Function",
        "doc": "A knob which evaluates it's string value as a TCL expression. It provides a multiline text area when it appears in a Node panel."
    },
    {
        "name": "Node",
        "type": "Function",
        "doc": "No documentation available."
    },
    {
        "name": "NodeConstructor",
        "type": "Function",
        "doc": "NodeConstructor"
    },
    {
        "name": "Nodes",
        "type": "Function",
        "doc": "Nodes"
    },
    {
        "name": "Obsolete_Knob",
        "type": "Function",
        "doc": "For internal use only."
    },
    {
        "name": "OneView_Knob",
        "type": "Function",
        "doc": "OneView_Knob"
    },
    {
        "name": "OutputContext",
        "type": "Function",
        "doc": "Describes a context in which expressions can be evaluated."
    },
    {
        "name": "Panel",
        "type": "Function",
        "doc": "Panel"
    },
    {
        "name": "PanelNode",
        "type": "Function",
        "doc": "PanelNode"
    },
    {
        "name": "ParticleChannels_Knob",
        "type": "Function",
        "doc": "ParticleChannels_Knob"
    },
    {
        "name": "Password_Knob",
        "type": "Function",
        "doc": "A knob which holds a password string value. Appears as a password entry field in a Node panel."
    },
    {
        "name": "PathExpression_Knob",
        "type": "Function",
        "doc": "Stores a Prim path expression."
    },
    {
        "name": "Path_Knob",
        "type": "Function",
        "doc": "Stores a Prim path."
    },
    {
        "name": "Precomp",
        "type": "Function",
        "doc": "No documentation available."
    },
    {
        "name": "ProgressTask",
        "type": "Function",
        "doc": "ProgressTask"
    },
    {
        "name": "Pulldown_Knob",
        "type": "Function",
        "doc": "Pulldown_Knob"
    },
    {
        "name": "PyCustom_Knob",
        "type": "Function",
        "doc": "PyCustom_Knob"
    },
    {
        "name": "PyScript_Knob",
        "type": "Function",
        "doc": "PyScript_Knob(name, label=None, command=None)\nA button that executes a Python script."
    },
    {
        "name": "PythonCustomKnob",
        "type": "Function",
        "doc": "PythonCustomKnob"
    },
    {
        "name": "PythonKnob",
        "type": "Function",
        "doc": "A string-valued knob which evaluates its value as a Python expression."
    },
    {
        "name": "Radio_Knob",
        "type": "Function",
        "doc": "Stores a single value between 0 and some maximum, and manages a\nset of Radio Buttons visible to the user. This is essentially an\nEnumeration_Knob with a different widget."
    },
    {
        "name": "Range_Knob",
        "type": "Function",
        "doc": "A knob which the minimum and maximum for a range of values."
    },
    {
        "name": "Root",
        "type": "Function",
        "doc": "No documentation available."
    },
    {
        "name": "RunInMainThread",
        "type": "Function",
        "doc": "RunInMainThread"
    },
    {
        "name": "Scale_Knob",
        "type": "Function",
        "doc": "Scale_Knob"
    },
    {
        "name": "SceneGraph_Knob",
        "type": "Function",
        "doc": "Displays a list of items as a hierarchy.\nThe hierarchy is specified using back or forward slashes within the item names\nto specify their level in the tree. Handles multiple selection of items within the tree."
    },
    {
        "name": "SceneView_Knob",
        "type": "Function",
        "doc": "Displays a list of items as a hierarchy.\nThe hierarchy is specified using back or forward slashes within the item names\nto specify their level in the tree. Handles multiple selection of items within the tree."
    },
    {
        "name": "Script_Knob",
        "type": "Function",
        "doc": "A button which executes a TCL script."
    },
    {
        "name": "String_Knob",
        "type": "Function",
        "doc": "A knob which holds a string value. Appears as a text entry field in a Node panel."
    },
    {
        "name": "Tab_Knob",
        "type": "Function",
        "doc": "Groups subsequent knobs onto a tab."
    },
    {
        "name": "Text_Knob",
        "type": "Function",
        "doc": "A knob which holds a string value."
    },
    {
        "name": "ToolBar",
        "type": "Function",
        "doc": "ToolBar"
    },
    {
        "name": "Transform2d_Knob",
        "type": "Function",
        "doc": "Transform2d_Knob"
    },
    {
        "name": "UV_Knob",
        "type": "Function",
        "doc": "A knob which describes a texture coordinate."
    },
    {
        "name": "Undo",
        "type": "Function",
        "doc": "Undo"
    },
    {
        "name": "Unsigned_Knob",
        "type": "Function",
        "doc": "A knob which holds one or more unsigned integer values."
    },
    {
        "name": "View",
        "type": "Function",
        "doc": "A named view."
    },
    {
        "name": "ViewView_Knob",
        "type": "Function",
        "doc": "ViewView_Knob"
    },
    {
        "name": "Viewer",
        "type": "Function",
        "doc": "No documentation available."
    },
    {
        "name": "ViewerProcess",
        "type": "Function",
        "doc": "ViewerProcess"
    },
    {
        "name": "ViewerWindow",
        "type": "Function",
        "doc": "ViewerWindow"
    },
    {
        "name": "WH_Knob",
        "type": "Function",
        "doc": "A knob which holds width and height values."
    },
    {
        "name": "XYZ_Knob",
        "type": "Function",
        "doc": "A knob which holds a 3D coordinate."
    },
    {
        "name": "XY_Knob",
        "type": "Function",
        "doc": "A knob which describes a 2D position."
    },
    {
        "name": "activeViewer",
        "type": "Function",
        "doc": "activeViewer() -> ViewerWindow\n\nReturn an object representing the active Viewer panel. This\nis not the same as the Viewer node, this is the viewer UI element.\n\n:return: Object representing the active ViewerWindow"
    },
    {
        "name": "addAfterBackgroundFrameRender",
        "type": "Function",
        "doc": "Add code to execute after each frame of a background render.\n  The call must be in the form of:\n  def foo(context):\n    pass\n\n  The context object that will be passed in is a dictionary containing the following elements:\n  id => The identifier for the task that's making progress\n  frame => the current frame number being rendered\n  numFrames => the total number of frames that is being rendered\n  frameProgress => the number of frames rendered so far.\n\n  Please be aware that the current Nuke context will not make sense in the callback (e.g. nuke.thisNode will return a random node).\n  "
    },
    {
        "name": "addAfterBackgroundRender",
        "type": "Function",
        "doc": "Add code to execute after any background renders.\n  The call must be in the form of:\n  def foo(context):\n    pass\n\n  The context object that will be passed in is a dictionary containing the following elements:\n  id => The identifier for the task that's ended\n\n  Please be aware that the current Nuke context will not make sense in the callback (e.g. nuke.thisNode will return a random node).\n  "
    },
    {
        "name": "addAfterFrameRender",
        "type": "Function",
        "doc": "Add code to execute after each frame of a render"
    },
    {
        "name": "addAfterRecording",
        "type": "Function",
        "doc": "Add code to execute after viewer recording"
    },
    {
        "name": "addAfterRender",
        "type": "Function",
        "doc": "Add code to execute after any renders"
    },
    {
        "name": "addAfterReplay",
        "type": "Function",
        "doc": "Add code to execute after viewer replay"
    },
    {
        "name": "addAutoSaveDeleteFilter",
        "type": "Function",
        "doc": "addAutoSaveDeleteFilter(filter) -> None\n\n  Add a function to modify the autosave filename before Nuke attempts delete the autosave file.\n\n  Look at rollingAutoSave.py in the nukescripts directory for an example of using the auto save filters.\n\n  @param filter: A filter function.  The first argument to the filter is the current autosave filename.\n  This function should return the filename to delete or return None if no file should be deleted."
    },
    {
        "name": "addAutoSaveFilter",
        "type": "Function",
        "doc": "addAutoSaveFilter(filter) -> None\n\n  Add a function to modify the autosave filename before Nuke saves the current script on an autosave timeout.\n\n  Look at rollingAutoSave.py in the nukescripts directory for an example of using the auto save filters.\n\n  @param filter: A filter function.  The first argument to the filter is the current autosave filename.\n  The filter should return the filename to save the autosave to."
    },
    {
        "name": "addAutoSaveRestoreFilter",
        "type": "Function",
        "doc": "addAutoSaveRestoreFilter(filter) -> None\n\n  Add a function to modify the autosave restore file before Nuke attempts to restores the autosave file.\n\n  Look at rollingAutoSave.py in the nukescripts directory for an example of using the auto save filters.\n\n  @param filter: A filter function.  The first argument to the filter is the current autosave filename.\n  This function should return the filename to load autosave from or it should return None if the autosave file should be ignored."
    },
    {
        "name": "addAutolabel",
        "type": "Function",
        "doc": "Add code to execute on every node to produce the text to draw on it\n  in the DAG. Any value other than None is converted to a string and used\n  as the text. None indicates that previously-added functions should\n  be tried"
    },
    {
        "name": "addBeforeBackgroundRender",
        "type": "Function",
        "doc": "Add code to execute before starting any background renders.\n  The call must be in the form of:\n  def foo(context):\n    pass\n\n  The context object that will be passed in is a dictionary containing the following elements:\n  id => The identifier for the task that's about to begin\n\n  Please be aware that the current Nuke context will not make sense in the callback (e.g. nuke.thisNode will return a random node).\n  "
    },
    {
        "name": "addBeforeFrameRender",
        "type": "Function",
        "doc": "Add code to execute before each frame of a render"
    },
    {
        "name": "addBeforeRecording",
        "type": "Function",
        "doc": "Add code to execute before viewer recording"
    },
    {
        "name": "addBeforeRender",
        "type": "Function",
        "doc": "Add code to execute before starting any renders"
    },
    {
        "name": "addBeforeReplay",
        "type": "Function",
        "doc": "Add code to execute before viewer replay"
    },
    {
        "name": "addDefaultColorspaceMapper",
        "type": "Function",
        "doc": "\n  Add a function to modify default colorspaces before Nuke passes them to\n  Readers or Writers.\n\n  Functions should have the same positional argument as in the definition of\n  defaultLUTMapper()\n\n  All added functions are called in backwards order.\n  "
    },
    {
        "name": "addFavoriteDir",
        "type": "Function",
        "doc": "addFavoriteDir(name, directory, type, icon, tooltip, key) -> None.\n\nAdd a path to the file choosers favorite directory list. The path name can contain environment variables which will be expanded when the user clicks the favourites button\n\n:param name: Favourite path entry ('Home', 'Desktop', etc.).\n:param directory: FileChooser will change to this directory path.\n:param type: Optional bitwise OR combination of nuke.IMAGE, nuke.SCRIPT, nuke.FONT or nuke.GEO.\n:param icon: Optional filename of an image to use as an icon.\n:param tooltip: Optional short text to explain the path and the meaning of the name.\n:param key: Optional shortcut key.\n:return: None."
    },
    {
        "name": "addFilenameFilter",
        "type": "Function",
        "doc": "Add a function to modify filenames before Nuke passes them to\n  the operating system. The first argument to the function is the\n  filename, and it should return the new filename. None is the same as\n  returning the string unchanged. All added functions are called\n  in backwards order."
    },
    {
        "name": "addFormat",
        "type": "Function",
        "doc": "addFormat(s) -> Format or None.\n\nCreate a new image format, which will show up on the pull-down menus for image formats.\nYou must give a width and height and name. The xyrt rectangle describes the image area, if\nit is smaller than the width and height (for Academy aperture, for example). The\npixel aspect is the ratio of the width of a pixel to the height.\n\n:param s: String in TCL format \\w h ?x y r t? ?pa? name\\.\n:return: Format or None."
    },
    {
        "name": "addKnobChanged",
        "type": "Function",
        "doc": "Add code to execute when the user changes a knob\n  The knob is availble in nuke.thisKnob() and the node in nuke.thisNode().\n  This is also called with dummy knobs when the control panel is opened\n  or when the inputs to the node changes. The purpose is to update other\n  knobs in the control panel. Use addUpdateUI() for changes that\n  should happen even when the panel is closed."
    },
    {
        "name": "addNodePresetExcludePaths",
        "type": "Function",
        "doc": "addNodePresetExcludePaths( paths ) -> None\n\nAdds a list of paths that will be excluded from Node preset search paths.\n\n:param: paths Sequence of paths to exclude\n:return: None."
    },
    {
        "name": "addOnCreate",
        "type": "Function",
        "doc": "Add code to execute when a node is created or undeleted"
    },
    {
        "name": "addOnDestroy",
        "type": "Function",
        "doc": "Add code to execute when a node is destroyed"
    },
    {
        "name": "addOnScriptClose",
        "type": "Function",
        "doc": "Add code to execute before a script is closed"
    },
    {
        "name": "addOnScriptLoad",
        "type": "Function",
        "doc": "Add code to execute when a script is loaded"
    },
    {
        "name": "addOnScriptSave",
        "type": "Function",
        "doc": "Add code to execute before a script is saved"
    },
    {
        "name": "addOnUserCreate",
        "type": "Function",
        "doc": "Add code to execute when user creates a node"
    },
    {
        "name": "addRenderProgress",
        "type": "Function",
        "doc": "Add code to execute when the progress bar updates during any renders"
    },
    {
        "name": "addSequenceFileExtension",
        "type": "Function",
        "doc": "addSequenceFileExtension( fileExtension )\n\nAdds the input file extension to the list of extensions that will get displayed as sequences in the file browser.\n\n:param fileExtension: the new file extension. Valid examples are: 'exr', '.jpg'; invalid examples are: 'somefile.ext'"
    },
    {
        "name": "addToolsetExcludePaths",
        "type": "Function",
        "doc": "addToolsetExcludePaths( paths ) -> None\n\n:param paths Sequence of paths to exclude. Adds a list of paths that will be excluded from Toolset search paths.\n:return: None."
    },
    {
        "name": "addUpdateUI",
        "type": "Function",
        "doc": "Add code to execute on every node when things change. This is done\n  during idle, you cannot rely on it being done before it starts updating\n  the viewer"
    },
    {
        "name": "addValidateFilename",
        "type": "Function",
        "doc": "Add a function to validate a filename in Write nodes. The first argument\n  is the filename and it should return a Boolean as to whether the filename is valid\n  or not. If a callback is provided, it will control whether the Render button of Write nodes\n  and the Execute button of WriteGeo nodes is enabled or not."
    },
    {
        "name": "addView",
        "type": "Function",
        "doc": "addView(s) -> None\n\nDeprecated. Use the Root node.\n\nAdds a new view to the list of views.\n\n:param s: View name.\n:return: None"
    },
    {
        "name": "afterBackgroundFrameRender",
        "type": "Function",
        "doc": "No documentation available."
    },
    {
        "name": "afterBackgroundRender",
        "type": "Function",
        "doc": "No documentation available."
    },
    {
        "name": "afterFrameRender",
        "type": "Function",
        "doc": "No documentation available."
    },
    {
        "name": "afterRecording",
        "type": "Function",
        "doc": "No documentation available."
    },
    {
        "name": "afterRender",
        "type": "Function",
        "doc": "No documentation available."
    },
    {
        "name": "afterReplay",
        "type": "Function",
        "doc": "No documentation available."
    },
    {
        "name": "alert",
        "type": "Function",
        "doc": "alert(prompt) -> None\n\nShow a warning dialog box. Pops up a warning box\nand waits for the user to hit the OK button.\n\n:param prompt: Present user with this message.\n:return: None"
    },
    {
        "name": "allNodes",
        "type": "Function",
        "doc": "allNodes(filter, group) -> List.\n\nList of all nodes in a group. If you need to get all the nodes in the script\nfrom a context which has no child nodes, for instance a control panel, use\nnuke.root().nodes().\n\n:param filter: Optional. Only return nodes of the specified class.\n:param group: Optional. If the group is omitted the current group (ie the group the user picked a menu item from the toolbar of) is used.\n:param recurseGroups: Optional. If True, will also return all child nodes within any group nodes. This is done recursively and defaults to False.\n:return: List"
    },
    {
        "name": "animation",
        "type": "Function",
        "doc": "animation(object, *commands) -> None\n\nDoes operations on an animation curve.\n\nThe following commands are supported:\n  - B{clear} deletes all the keys from the animation.\n  - B{erase} C{index I{last_index}} removes all keyframes between index and last_index\n  - B{expression} C{I{newvalue}} returns or sets the expression for\n    the animation. The default is 'curve' or 'y' which returns the interpolation of the keys.\n  - B{generate} C{start end increment field expression I{field expression} ...}\n    generates an animation with start, end, and increment. Multiple field/expression pairs\n    generate a keyframe. Possible field commands are:\n      - B{x} sets the frame number for the next keyframe\n      - B{y} sets the keyframe value\n      - B{dy} sets the left slope\n      - B{ldy} sets left and right slope to the same value\n      - B{la} and B{ra} are the length of the slope handle in x direction. A value of 1\n        generates a handle that is one third of the distance to the next keyframe.\n  - B{index} C{x} returns the index of the last key with x <= t, return -1 for none.\n  - B{is_key} return non-zero if there is a key with x == t. The actual return value is the index+1.\n  - B{move} C{field expression I{field expression}} replaces all selected keys\n    in an animation with new ones as explained above in B{generate}\n  - B{name} returns a user-friendly name for this animation. This will eliminate\n    any common prefix between this animation and all other selected ones,\n    and also replaces mangled names returned by animations with nice ones.\n  - B{size} returns the number of keys in the animation.\n  - B{test} errors if no points in the animation are selected\n  - B{y} index C{I{newvalue}} gets or sets the value of an animation.\n  - B{x} index C{I{newvalue}} gets or sets the horizontal postion of a key.\n    If the animation contains an expression or keyframes, the new value will be overridden.\n\nSee also: animations\n\n:param object: The animation curve.\n:param commands: a varargs-style list of commands, where each command is one of those defined above.\n:return: None"
    },
    {
        "name": "animationEnd",
        "type": "Function",
        "doc": "animationEnd() -> float.\n\nReturns the last frame (or x value) for the currently selected animations.\n\n:return: The end frame."
    },
    {
        "name": "animationIncrement",
        "type": "Function",
        "doc": "animationIncrement() -> float\n\nReturns a recommended interval between samples of the currently selected animation.\n\n:return: The recommended interval."
    },
    {
        "name": "animationStart",
        "type": "Function",
        "doc": "animationStart() -> float\n\nReturns the starting frame (or x value) for the currently selected animations.\n\n:return: The start frame."
    },
    {
        "name": "animations",
        "type": "Function",
        "doc": "animations() -> tuple\n\nReturns a list of animatable things the user wants to work on.\n\nIf this is a command being executed from a menu item in a curve editor, a list of the names of all selected curves is returned. If this list is empty a \"No curves selected\" error is produced.\n\nIf this is a command being executed from the pop-up list in a knob then a list of all the fields in the knob is returned.\n\nIf this is a command being executed from the right-mouse-button pop-up list in a field of a knob, the name of that field is returned.\n\nOtherwise this produces an error indicating that the command requries a knob context. You can get such a context by doing \"in <knob> {command}\"\n\nAlso see the 'selected' argument to the animation command.\n\nSee also: animation, animationStart, animationEnd, animationIncrement\n\n:return: A tuple of animatable things."
    },
    {
        "name": "applyPreset",
        "type": "Function",
        "doc": "applyPreset(nodeName, presetName) -> None\n\nApplies a given preset to the current node.\n\n:param nodeName: Name of the node to apply the preset to.\n:param presetName: Name of the preset to use.\n:param node: (optional) a Node object to apply the preset to. If this is provided, the nodeName parameter is ignored.\n:return: bool."
    },
    {
        "name": "applyUserPreset",
        "type": "Function",
        "doc": "applyUserPreset(nodeName, presetName) -> None\n\nApplies a given user preset to the current node.\n\n:param nodeName: Name of the node to apply the preset to.\n:param presetName: Name of the preset to use.\n:param node: (optional) a Node object to apply the preset to. If this is provided, the nodeName parameter is ignored.\n:return: bool."
    },
    {
        "name": "ask",
        "type": "Function",
        "doc": "ask(prompt) -> bool\n\nShow a Yes/No dialog.\n\n:param prompt: Present the user with this message.\n:return: True if Yes, False otherwise."
    },
    {
        "name": "askWithCancel",
        "type": "Function",
        "doc": "askWithCancel(prompt) -> bool\n\nShow a Yes/No/Cancel dialog.\n\n:param prompt: Present the user with this question.\n:return: True if Yes, False if No, an exception is thrown if Cancel."
    },
    {
        "name": "autoSaveDeleteFilter",
        "type": "Function",
        "doc": "Internal function.  Use addAutoSaveDeleteFilter to add a callback"
    },
    {
        "name": "autoSaveFilter",
        "type": "Function",
        "doc": "Internal function.  Use addAutoSaveFilter to add a callback"
    },
    {
        "name": "autoSaveRestoreFilter",
        "type": "Function",
        "doc": "Internal function.  Use addAutoSaveRestoreFilter to add a callback"
    },
    {
        "name": "autolabel",
        "type": "Function",
        "doc": "No documentation available."
    },
    {
        "name": "autoplace",
        "type": "Function",
        "doc": "autoplace(n) -> None.\n\nDeprecated. Use Node.autoplace.\n\nAutomatically place nodes, so they do not overlap.\n\n:param n: Node.\n:return: None"
    },
    {
        "name": "autoplaceSnap",
        "type": "Function",
        "doc": "autoplaceSnap(n) -> None\n\nMove node to the closest grid position.\n\n:param n: Node.\n:return: None"
    },
    {
        "name": "autoplace_all",
        "type": "Function",
        "doc": "autoplace_all() -> None.\n\nPerforms autoplace of all nodes in current context group.\n\n:return: None. May return exception it top context group has subgraph locked."
    },
    {
        "name": "autoplace_snap_all",
        "type": "Function",
        "doc": "autoplace_snap_all() -> None.\n\nPerforms autoplace snap of all nodes in current context group.\n\n:return: None. May return exception it top context group has subgraph locked."
    },
    {
        "name": "autoplace_snap_selected",
        "type": "Function",
        "doc": "autoplace_snap_selected() -> None.\n\nPerforms autoplace snap of all selected nodes in current context group.\n\n:return: None. May return exception it top context group has subgraph locked."
    },
    {
        "name": "beforeBackgroundRender",
        "type": "Function",
        "doc": "No documentation available."
    },
    {
        "name": "beforeFrameRender",
        "type": "Function",
        "doc": "No documentation available."
    },
    {
        "name": "beforeRecording",
        "type": "Function",
        "doc": "No documentation available."
    },
    {
        "name": "beforeRender",
        "type": "Function",
        "doc": "No documentation available."
    },
    {
        "name": "beforeReplay",
        "type": "Function",
        "doc": "No documentation available."
    },
    {
        "name": "cacheUsage",
        "type": "Function",
        "doc": "cacheUsage() -> int\n\nGet the total amount of memory currently used by the cache.\n\n:return: Current memory usage in bytes."
    },
    {
        "name": "canCreateNode",
        "type": "Function",
        "doc": "canCreateNode(name) -> True if the node can be created, or False if not.\n\nThis function can be used to determine whether it is possible to create a node with the specified node class.\n\n:param name: Node name.\n:return: True if the node can be created, or False if not."
    },
    {
        "name": "cancel",
        "type": "Function",
        "doc": "cancel() -> None\n\nCancel an in-progress operation. This has the same effect as hitting cancel on the progress panel.\n\n:return: None"
    },
    {
        "name": "center",
        "type": "Function",
        "doc": "center() -> array with x, then y\n\nReturn the center values of a group's display, these values are suitable to be passed to nuke.zoom as the DAG center point.  Like so:\n\n.. code-block:: python\n    center = nuke.center()\n    zoom = nuke.zoom()\n    print center[0]\n    print center[1]\n    ## move DAG back to center point without changing zoom.\n    nuke.zoom( zoom, center )\n:return: Array of x, y."
    },
    {
        "name": "channels",
        "type": "Function",
        "doc": "channels(n=None) -> (string)\n\nDeprecated. Use Node.channels.\n\nList channels. The n argument is a Nuke node and if given only the channels\noutput by this node are listed. If not given or None, all channels known about\nare listed.\n\n:param n: Optional node parameter.\n:return: A list of channel names."
    },
    {
        "name": "choice",
        "type": "Function",
        "doc": "choice(title, prompt, options, default = 0) -> index\n\nShows a dialog box with the given title and prompt text, and a combo box containing the given options.\n\n:param title: Text to put in the dialog's title bar.\n:param prompt: Text to display at the top of the dialog.\n:param options: A list of strings for the user to choose from.\n:param default: The index (starting from zero) of the option to select first.\n:return: An integer index (starting from zero) of the choice the user selected, or None if the dialog was cancelled."
    },
    {
        "name": "clearAssetCache",
        "type": "Function",
        "doc": "clearAssetCache() -> None\n\nClear the Asset cache."
    },
    {
        "name": "clearBlinkCache",
        "type": "Function",
        "doc": "clearBlinkCache() -> None\n\nClear the Blink cache for all devices."
    },
    {
        "name": "clearDiskCache",
        "type": "Function",
        "doc": "clearDiskCache() -> None\n\nClear the disk cache of all files."
    },
    {
        "name": "clearGeoSelection",
        "type": "Function",
        "doc": "clearGeoSelection() -> None\n\nClear currently selected geometry.\n\n:return: None."
    },
    {
        "name": "clearRAMCache",
        "type": "Function",
        "doc": "clearRAMCache() -> None\n\nClear the RAM cache of all files."
    },
    {
        "name": "clearTabMenuFavorites",
        "type": "Function",
        "doc": "clearTabMenuFavorites() -> None\n\nUncheck every favourite node in tab search menu."
    },
    {
        "name": "clearTabMenuWeighting",
        "type": "Function",
        "doc": "clearTabMenuWeighting() -> None\n\nSet the weight of each node to 0 in tab search menu."
    },
    {
        "name": "clone",
        "type": "Function",
        "doc": "clone(n, args, inpanel) -> Node\n\nCreate a clone node that behaves identical to the original. The node argument is the node to be cloned, args and inpanel are optional arguments similar to createNode.\nA cloned node shares the exact same properties with its original. Clones share the same set of knobs and the same control panel. However they can\nhave different positions and connections in the render tree. Any clone, including the original, can be deleted at any time without harming any of its clones.\n\n:param n: Node.\n:param args: Optional number of inputs requested.\n:param inpanel: Optional boolean.\n:return: Node"
    },
    {
        "name": "cloneSelected",
        "type": "Function",
        "doc": "cloneSelected(action) -> bool\n\nThis makes a clone of all selected nodes, preserving connections between them, and makes only the clones be selected.\n\n:param action: Optional and if 'copy' it cuts the resulting clones to the clipboard.\n:return: True if succeeded, False otherwise."
    },
    {
        "name": "collapseToGroup",
        "type": "Function",
        "doc": "collapseToGroup(show=True) -> Group\n\nMoves the currently selected nodes to a new group, maintaining their previous connections.\n\n:param show: If show is True, the node graph for the new group is shown in the background.\n:return: The new Group node."
    },
    {
        "name": "collapseToLiveGroup",
        "type": "Function",
        "doc": "collapseToLiveGroup(show=True) -> Group\n\nMoves the currently selected nodes to a new group, maintaining their previous connections.\n\n:param show: If show is True, the node graph for the new group is shown in the background.\n:return: The new Group node."
    },
    {
        "name": "connectNodes",
        "type": "Function",
        "doc": "connectNodes() -> None\n\nDeprecated. Use Group.connectSelectedNodes.\n\n:return: None"
    },
    {
        "name": "connectViewer",
        "type": "Function",
        "doc": "connectViewer(inputNum, node) -> None\n\nConnect a viewer input to a node. The argument i is the input number and n is either a Nuke node or None.\nSome viewer in the current group is found, if there are no viewers one is created. The\nviewer is then altered to have at least n+1 inputs and then input n is connected to the given node.\nThis function is used by the numeric shortcuts in the DAG view menu.\n\n:param inputNum: Input number.\n:param node: The Node to connect to the input.\n:return: None"
    },
    {
        "name": "createLiveInput",
        "type": "Function",
        "doc": "createLiveInput() -> Node\n\nCreates a new LiveInput and populates the \\file\\ and \\liveGroup\\ knobs according to the\nfilename and LiveGroup name of the parent group\n\n:return: The new LiveInput_Node."
    },
    {
        "name": "createNode",
        "type": "Function",
        "doc": "createNode(node, args, inpanel) -> Node.\n\nCreates a node of the specified type and adds it to the DAG.\n\n:param node: Node class (e.g. Blur).\n:param args: Optional string containing a TCL list of name value pairs (like \\size 50 quality 19\\)\n:param inpanel: Optional boolean to open the control bin (default is True; only applies when the GUI is running).\n:return: Node."
    },
    {
        "name": "createScenefileBrowser",
        "type": "Function",
        "doc": "createScenefileBrowser( fileName, nodeName ) -> None\n\nPops up a scene browser dialog box.\nReceives the path to an Alembic (abc) or Universal Scene Description (usd/usda/usdc/usdz) file,\nand displays a hierarchical tree of the nodes within the file.\nThe user can select which nodes they are interested in, and nodes of the appropriate type will automatically.\nbe created.\nIf a valid scene file nodeName is specified, this node will be populated with the selected tree.\n\n:param fileName: Path and filename for an alembic or usd/usda/usdc/usdz file.\n:param nodeName: name of a valid scene file node to populate. If the node is invalid, new nodes will be automatically created"
    },
    {
        "name": "createToolset",
        "type": "Function",
        "doc": "createToolset(filename=None, overwrite=-1, rootPath = None) -> None\n\nCreates a tool preset based on the currently selected nodes.\n\n:param filename: Saves the preset as a script with the given file name.\n:param overwrite: If 1 (true) always overwrite; if 0 (false) never overwrite;\n:param rootPath: If specified, use this as the root path to save the Toolset to. If not specified, save to the user's .nuke/Toolsets folder.\n otherwise, in GUI mode ask the user, in terminal do same as False. Default\n is -1, meaning 'ask the user'."
    },
    {
        "name": "critical",
        "type": "Function",
        "doc": "critical(message)-> None\n\nPuts the message into the error console, treating it like an error. Also pops up an alert dialog to the user, immediately.\n\n:param message: String parameter.\n:return: None."
    },
    {
        "name": "debug",
        "type": "Function",
        "doc": "debug(message)-> None\n\nPuts the message into the error console, treating it like a debug message, which only shows up when the verbosity level is high enough.\n\n:param message: String parameter.\n:return: None."
    },
    {
        "name": "defaultColorspaceMapper",
        "type": "Function",
        "doc": "\n  Called by libnuke.\n  Calls into Node-level callbacks first, then global callbacks\n\n  Arguments:\n      colorspace   - the name string of the initial colorspace\n      dataTypeHint - sometimes Readers/Writer request the default for a\n                     particular data-type, i.e. int8, in16, float, etc.\n  Return:\n      The return should be the transformed/modified colorspace name.\n      None is the same as returning the string unchanged.\n  "
    },
    {
        "name": "defaultFontPathname",
        "type": "Function",
        "doc": "defaultFontPathname() -> str\n\nGet the path to Nukes default font.\n\n:return: Path to the font."
    },
    {
        "name": "defaultNodeColor",
        "type": "Function",
        "doc": "defaultNodeColor(s) -> int\n\nGet the default node colour.\n\n:param s: Node class.\n:return: The color as a packed integer (0xRRGGBB00)."
    },
    {
        "name": "delete",
        "type": "Function",
        "doc": "delete(n) -> None\n\nThe named node is deleted. It can be recovered with an undo.\n\n:param n: Node.\n:return: None"
    },
    {
        "name": "deletePreset",
        "type": "Function",
        "doc": "deletePreset(nodeClassName, presetName) -> None\n\nDeletes a pre-created node preset\n\n:param nodeClassName: Name of the node class to create a preset for.\n:param presetName: Name of the preset to create.\n:return: bool."
    },
    {
        "name": "deleteUserPreset",
        "type": "Function",
        "doc": "deleteUserPreset(nodeClassName, presetName) -> None\n\nDeletes a pre-created user node preset\n\n:param nodeClassName: Name of the node class to create a preset for.\n:param presetName: Name of the preset to create.\n:return: bool."
    },
    {
        "name": "deleteView",
        "type": "Function",
        "doc": "deleteView(s) -> None\n\nDeprecated. Use the Root node.\n\nDeletes a view from the list of views.\n\n:param s: View name.\n:return: None"
    },
    {
        "name": "dependencies",
        "type": "Function",
        "doc": " List all nodes referred to by the nodes argument. 'what' is an optional integer (see below).\n  You can use the following constants or'ed together to select the types of dependencies that are looked for:\n  \t nuke.EXPRESSIONS = expressions\n  \t nuke.LINKINPUTS = link knob inputs\n  \t nuke.INPUTS = visible input pipes\n  \t nuke.HIDDEN_INPUTS = hidden input pipes.\n  The default is to look for all types of connections.\n  \nExample:\n  n1 = nuke.nodes.Blur()\n  n2 = nuke.nodes.Merge()\n  n2.setInput(0, n1)\n  deps = nuke.dependencies([n2], nuke.INPUTS | nuke.HIDDEN_INPUTS | nuke.EXPRESSIONS)"
    },
    {
        "name": "dependentNodes",
        "type": "Function",
        "doc": " List all nodes referred to by the nodes argument. 'what' is an optional integer (see below).\n  You can use the following constants or'ed together to select what types of dependent nodes are looked for:\n  \t nuke.EXPRESSIONS = expressions\n  \t nuke.LINKINPUTS = link knob inputs\n  \t nuke.INPUTS = visible input pipes\n  \t nuke.HIDDEN_INPUTS = hidden input pipes.\n  The default is to look for all types of connections.\n\n  evaluateAll is an optional boolean defaulting to True. When this parameter is true, it forces a re-evaluation of the entire tree.\n  This can be expensive, but otherwise could give incorrect results if nodes are expression-linked.\n\n  \nExample:\n  n1 = nuke.nodes.Blur()\n  n2 = nuke.nodes.Merge()\n  n2.setInput(0, n1)\n  ndeps = nuke.dependentNodes(nuke.INPUTS | nuke.HIDDEN_INPUTS | nuke.EXPRESSIONS, [n1])\n\n  @param what: Or'ed constant of nuke.EXPRESSIONS, nuke.LINKINPUTS, nuke.INPUTS and nuke.HIDDEN_INPUTS to select the types of dependent nodes. The default is to look for all types of connections.\n  @param evaluateAll: Specifies whether a full tree evaluation will take place. Defaults to True.\n  @return: List of nodes. "
    },
    {
        "name": "display",
        "type": "Function",
        "doc": "display(s, node, title, width) -> None.\n\nCreates a window showing the result of a python script. The script is\nexecuted in the context of the given node, so this and a knob\nname in expressions refer to that node.\n\nThe window will have an 'update' button to run the script again.\n\n:param s: Python script.\n:param node: Node.\n:param title: Optional title of window.\n:param width: Optional width of window.\n:return: None."
    },
    {
        "name": "duplicateSelectedNodes",
        "type": "Function",
        "doc": "duplicateSelectedNodes() -> None.\n\nCreates a duplicate of all selected nodes in the current script context group\n\n:return: None. May return exception it top context group has subgraph locked."
    },
    {
        "name": "endGroup",
        "type": "Function",
        "doc": "endGroup() -> None\n\n**Deprecated**. Use Group.run, Group.begin/Group.end pairs or (preferably) the with statement.\n\nChanges the current group to the parent of the current group. Does nothing if the current group is a Root (the main window of a script).\n\n:return: None."
    },
    {
        "name": "error",
        "type": "Function",
        "doc": "error(message)-> None\n\nPuts the message into the error console, treating it like an error.\n\n:param message: String parameter.\n:return: None.\n"
    },
    {
        "name": "execute",
        "type": "Function",
        "doc": "execute(nameOrNode, start, end, incr, views, continueOnError = False) -> None.\nexecute(nameOrNode, frameRangeSet, views, continueOnError = False) -> None.\\n\n\nExecute the named Write node over the specified frames.\n\nThere are two variants of this function. The first allows you to specify the\nframes to write range by giving the start frame number, the end frame number\nand the frame increment. The second allows you to specify more complicated\nsets of frames by providing a sequence of FrameRange objects.\n\nIf Nuke is run with the GUI up, this will pop up a progress meter. If the user hits\nthe cancel button this command will return 'cancelled' error.\nIf Nuke is run from the nuke command line (ie nuke was started with the -t switch)\nexecute() prints a text percentage as it progresses.\nIf the user types ^C it will aborting the execute() and return a 'cancelled' error.\n\n:param nameOrNode: A node name or a node object.\n:param start: Optional start frame. Default is root.first_frame.\n:param end: Optional end frame. Default is root.last_frame.\n:param incr: Optional increment. Default is 1.\n:param views: Optional list of views. Default is None, meaning \\all views\\.\n:return: None"
    },
    {
        "name": "executeBackgroundNuke",
        "type": "Function",
        "doc": "executeBackgroundNuke(exe_path, nodes, frameRange, views, limits, continueOnError = False, flipbookToRun = \", flipbookOptions = {}) -> None\n\nRun an instance of Nuke as a monitored sub process. Returns an integer that's used as unique id for the started task. If it failed to launch this will be -1.\n\n:param: exe_path: Path to Nuke or a script that can take Nuke arguments. You probably want to supply nuke.EXE_PATH.\n:param: nodes: A list of nodes to execute.\n:param: frameRanges: List of frame ranges to execute.\n:param: views: A list of view names to execute.\n:param: limits: A dictionary with system limits, currently uses keys maxThreads and maxCache.\n:param: flipbookToRun: The name of the flipbook application to run after the render, or an empty string if not desired.\n:param: flipbookOptions: A dictionary with options to pass to the flipbook. These should include roi and pixelAspect.\n:return: Int."
    },
    {
        "name": "executeInMainThread",
        "type": "Function",
        "doc": " Execute the callable 'call' with optional arguments 'args' and named\n  arguments 'kwargs' i n Nuke's main thread and return immediately. "
    },
    {
        "name": "executeInMainThreadWithResult",
        "type": "Function",
        "doc": " Execute the callable 'call' with optional arguments 'args' and named arguments 'kwargs' in\n      Nuke's main thread and wait for the result to become available. "
    },
    {
        "name": "executeMultiple",
        "type": "Function",
        "doc": "executeMultiple(nodes, ranges, views, continueOnError=False) -> None\n\nExecute the current script for a specified frame range. The argument nodes is\na sequence of Nuke nodes and ranges is a sequence of range lists. A Nuke range\nlist is a sequence of 3 integers - first, last and incr ( e.g. nuke.execute((w,), ((1,100,1),)) ).\nThe named nodes must all be Write or other executable operators. If no nodes\nare given then all executable nodes in the current group are executed.\nNote that DiskCache and Precomp nodes do not get executed with this call, unless explicitly specified.\n\nIf Nuke is run with the GUI up, this will pop up a progress meter. If the\nuser hits the cancel button this command will raise a 'cancelled' error. If\nNuke is run in terminal mode (with the -t switch) this prints a text\npercentage as it progresses.\n\nIf the user types ^C it will abort the execute() and raise a 'cancelled' error.\n\n:param nodes: Node list.\n:param ranges: Optional start frame. Default is root.first_frame.\n:param views: Optional list of views. Default is None. Execute for all.\n:return: None"
    },
    {
        "name": "executing",
        "type": "Function",
        "doc": "executing() -> Bool.\n\nReturns whether an Executable Node is currently active or not.\n\n:param f: Optional frame number.\n:return: Current bool."
    },
    {
        "name": "exists",
        "type": "Function",
        "doc": "exists(s) -> bool\n\nCheck for the existence of a named item.\nFunction for backwards-compatibility with TCL.\n\n:param s: Name of item.\n:return: True if exists, False otherwise."
    },
    {
        "name": "expandSelectedGroup",
        "type": "Function",
        "doc": "expandSelectedGroup() -> None\n\nMoves all nodes from the currently selected group node into its parent group,\nmaintaining node input and output connections, and deletes the group.\nReturns the nodes that were moved, which will also be selected.\n\n:return: None"
    },
    {
        "name": "expr",
        "type": "Function",
        "doc": "expression(s) -> float\n\nParse a Nuke expression. Runs the same expression parser as is used by animations. This is not the same as the tcl expr parser. The main differences are:\n\n- Only floating point numbers are calculated. There are no strings, boolean, or integer values.\n- You can name any knob that returns a floating point value, with a dot-separated name, see knob for details on these names. You may follow the knob name with a time in parenthesis (like a function call) and if it is animated it will be evaluated at that time. If it is animated and no time is given, 'frame' is used.\n- The words 'frame', 't', and 'x' evaluate to the frame number of the context node, or the frame number this animation is being evaluated at.\n- The word 'y' in an animation expression evaluates to the value the animation would have if the control points were used and there was no expression. Outside an animation expression y returns zero.\n\n:param s: The expression, as a string.\n:return: The result."
    },
    {
        "name": "expression",
        "type": "Function",
        "doc": "expression(s) -> float\n\nParse a Nuke expression. Runs the same expression parser as is used by animations. This is not the same as the tcl expr parser. The main differences are:\n\n- Only floating point numbers are calculated. There are no strings, boolean, or integer values.\n- You can name any knob that returns a floating point value, with a dot-separated name, see knob for details on these names. You may follow the knob name with a time in parenthesis (like a function call) and if it is animated it will be evaluated at that time. If it is animated and no time is given, 'frame' is used.\n- The words 'frame', 't', and 'x' evaluate to the frame number of the context node, or the frame number this animation is being evaluated at.\n- The word 'y' in an animation expression evaluates to the value the animation would have if the control points were used and there was no expression. Outside an animation expression y returns zero.\n\n:param s: The expression, as a string.\n:return: The result."
    },
    {
        "name": "extractSelected",
        "type": "Function",
        "doc": "extractSelected() -> None\n\nDisconnects the selected nodes in the group from the tree, and shifts them to the side.\n\n:return: None"
    },
    {
        "name": "filename",
        "type": "Function",
        "doc": "filename(node, i) -> str\n\nReturn the filename(s) this node or group is working with.\n\nFor a Read or Write operator (or anything else with a filename\nknob) this will return the current filename, based on the\nroot.proxy settings and which of the fullsize/proxy filenames are\nfilled in. All expansion of commands and variables is\ndone. However by default it will still have %%04d sequences in it,\nuse REPLACE to get the actual filename with the current frame number.\n\nIf the node is a group, a search is done for executable (i.e. Write)\noperators and the value from each of them is returned. This will duplicate\nthe result of calling execute() on the group.\n\n:param node: Optional node.\n:param i: Optional nuke.REPLACE. Will replace %%04d style sequences with the current frame number.\n:return: Filename, or None if no filenames are found."
    },
    {
        "name": "filenameFilter",
        "type": "Function",
        "doc": "No documentation available."
    },
    {
        "name": "forceClone",
        "type": "Function",
        "doc": "forceClone() -> bool\n\n:return: True if succeeded, False otherwise."
    },
    {
        "name": "forceLoad",
        "type": "Function",
        "doc": "forceLoad(n) -> None\n\nForce the plugin to be fully instantiated.\n\n:param n: Optional node argument. Default is the current node.\n:return: None"
    },
    {
        "name": "fork",
        "type": "Function",
        "doc": "Forks a new instance of Nuke optionally with the contents of the named file."
    },
    {
        "name": "formats",
        "type": "Function",
        "doc": "formats() -> list\n\n:return: List of all available formats."
    },
    {
        "name": "frame",
        "type": "Function",
        "doc": "frame(f) -> Current frame.\n\nReturn or set the current frame number. Deprecated. Use Root.frame.\n\nReturns the current frame. Normally this is the frame number set in the root\nnode, typically by the user moving the frame slider in a viewer. If a number is\ngiven, it sets the current frame number to that number. If the current context\nis the root this changes the root frame.\n\n:param f: Optional frame number.\n:return: Current frame."
    },
    {
        "name": "fromNode",
        "type": "Function",
        "doc": "fromNode(n) -> String.\n\nReturn the Node n as a string.\nThis function is most useful when combining Python and TCL scripts for backwards compatibility reasons.\n\n:param n: A Node.\n:return: String."
    },
    {
        "name": "getAllUserPresets",
        "type": "Function",
        "doc": "getAllUserPresets() -> None\n\nGets a list of all current user presets\n\n:return: a list of tuples containing all nodename/presetname pairs."
    },
    {
        "name": "getClipname",
        "type": "Function",
        "doc": "getClipname(prompt, pattern=None, default=None, multiple=False) -> list of strings or string\n\nPops up a file chooser dialog box. You can use the pattern to restrict the displayed choices to matching filenames,\nnormal Unix glob rules are used here. getClipname compresses lists of filenames that only differ by an index number\ninto a single entry called a 'clip'.\n\n:param prompt: Present the user with this message.\n:param pattern: Optional file selection pattern.\n:param default: Optional default filename and path.\n:param multiple: Optional boolean convertible object to allow for multiple\n selection.\n:return: If multiple is True, the user input is returned as a list of\n strings, otherwise as a single string. If the dialog is cancelled, the\n return value is None."
    },
    {
        "name": "getColor",
        "type": "Function",
        "doc": "getColor(initial) -> int\n\nShow a color chooser dialog and return the selected color as an int.\n\nThe format of the color values is packed 8bit rgb multiplied by 256 (ie in hex: 0xRRGGBB00).\n\n:param initial: Optional initial color. Integer with components packed as above.\n:return: The selected color."
    },
    {
        "name": "getColorspaceList",
        "type": "Function",
        "doc": "\n  Get a list of all colorspaces listed in an enumeration knob.\n  This will strip family names if the knob has the STRIP_CASCADE_PREFIX flag set.\n  "
    },
    {
        "name": "getDeletedPresets",
        "type": "Function",
        "doc": "getDeletedPresets() -> None\n\nGets a list of all currently deleted presets\n\n:return: a pyDict containing all nodename/presetname pairs."
    },
    {
        "name": "getFileNameList",
        "type": "Function",
        "doc": "getFileNameList( dir, splitSequences = False, extraInformation = False, returnDirs=True, returnHidden=False ) -> str\n\nRetrieves the filename list.\n\n:param: dir the directory to get sequences from\n:param: splitSequences whether to split sequences or not\n:param: extraInformation whether or not there should be extra sequence information on the sequence name\n:param: returnDirs whether to return a list of directories as well as sequences\n:param: returnHidden whether to return hidden files and directories.\n:return: Array of files."
    },
    {
        "name": "getFilename",
        "type": "Function",
        "doc": "getFilename(message, pattern=None, default=None, favorites=None, type=None, multiple=False) -> list of strings or single string\n\nPops up a file chooser dialog box. You can use the pattern to restrict the\ndisplayed choices to matching filenames, normal Unix glob rules are used\nhere.\n\n:param message: Present the user with this message.\n:param pattern: Optional file selection pattern.\n:param default: Optional default filename and path.\n:param favorites: Optional. Restrict favorites to this set. Must be one of 'image', 'script', or 'font'.\n:param type: Optional the type of browser, to define task-specific behaviors; currently only 'save' is recognised.\n:param multiple: Optional boolean convertible object to allow for multiple\n selection. If this is True, the return value will be a list of strings; if\n not, it will be a single string. The default is\n:return: If multiple is True, the user input is returned as a list of\n strings, otherwise as a single string. If the dialog was cancelled, the\n return value will be None."
    },
    {
        "name": "getFonts",
        "type": "Function",
        "doc": "getFonts() -> list of font  families and styl.\n\nReturn a list of all available font families and styles\n\n:return: List of font families and style."
    },
    {
        "name": "getFramesAndViews",
        "type": "Function",
        "doc": "getFramesAndViews(label, default=None, maxviews=0) -> (ranges, views)\n\nPops up a dialog with fields for a frame range and view selection.\n\n:param label: User message.\n:param default: Optional value for the input field.\n:param maxviews: Optional max number of views.\n:return: List of ranges and views."
    },
    {
        "name": "getGeoSelection",
        "type": "Function",
        "doc": "getGeoSelection() -> Returns the selection as a dictionary\n\n:return: Currently selected geometry"
    },
    {
        "name": "getInput",
        "type": "Function",
        "doc": "getInput(prompt, default) -> str\n\nPops up a dialog box with a text field for an arbitrary string.\n\n:param prompt: Present the user with this message.\n:param default: Default value for the input text field.\n:return: String from text field or None if dialog is cancelled."
    },
    {
        "name": "getNodeClassName",
        "type": "Function",
        "doc": "getNodeClassName() -> None\n\nGets the class name for the currently selected node\n\n:return: a string containing the name."
    },
    {
        "name": "getNodePresetExcludePaths",
        "type": "Function",
        "doc": "getNodePresetExcludePaths() -> string list\n\nGets a list of all paths that are excluded from the search for node presets.\n\n:return: List of paths."
    },
    {
        "name": "getNodePresetID",
        "type": "Function",
        "doc": "getNodePresetID() -> None\n\nGets the node preset identifier for the currently selected node\n\n:return: a string containing the ID."
    },
    {
        "name": "getOcioColorSpaces",
        "type": "Function",
        "doc": "getOcioColorSpaces() -> returns the list of OCIO colorspaces.\n\n:return: list of strings\n"
    },
    {
        "name": "getPaneFor",
        "type": "Function",
        "doc": "getPaneFor( panelName ) -> Dock\n\nReturns the first pane that contains the named panel or None if it can't be found.\nNote that the panelName must be exact as described in the layout.xml file or the panel ID.\nFor example, 'Properties.1' or 'Viewer.1 or 'co.uk.thefoundry.WebBrowser'\n\n:return: The pane or None."
    },
    {
        "name": "getPresetKnobValues",
        "type": "Function",
        "doc": "getPresetKnobValues() -> None\n\nGets a list of knob values for a given preset\n\n:param nodeClassName: Name of the node class to get values for.\n:param presetName: Name of the preset to get values for.\n:return: a pyDict containing all knob name/value pairs."
    },
    {
        "name": "getPresets",
        "type": "Function",
        "doc": "getPresets() -> None\n\nGets a list of all presets for the currently selected node's class\n\n:return: a pyList containing all nodename/presetname pairs."
    },
    {
        "name": "getPresetsMenu",
        "type": "Function",
        "doc": "getPresetsMenu(Node) -> Menu or None\n\nGets the presets menu for the currently selected node.\n\n:return: The menu, or None if it doesn't exist."
    },
    {
        "name": "getReadFileKnob",
        "type": "Function",
        "doc": "getReadFileKnob(node) -> knob\n\nGets the read knob for a node (if it exists).\n\n:param node: The node to get the knob for.\n\n:return: A PyObject containing the read knob if it exists, NULL otherwise"
    },
    {
        "name": "getRenderProgress",
        "type": "Function",
        "doc": "getRenderProgress() -> Returns the progress of the render of a frame from 0 - 100 % complete.\n\n:return: The progress of the render.  Can be 0 if there is no progress to report."
    },
    {
        "name": "getToolsetExcludePaths",
        "type": "Function",
        "doc": "getToolsetExcludePaths() -> string list\n\nGets a list of all paths that are excluded from the search for node presets.\n\n:return: List of paths."
    },
    {
        "name": "getUserPresetKnobValues",
        "type": "Function",
        "doc": "getUserPresetKnobValues() -> None\n\nGets a list of knob values for a given preset\n\n:param nodeClassName: Name of the node class to get values for.\n:param presetName: Name of the preset to get values for.\n:return: a pyDict containing all knob name/value pairs."
    },
    {
        "name": "getUserPresets",
        "type": "Function",
        "doc": "getUserPresets(Node) -> None\n\nGets a list of all user presets for the currently selected node's class\n\n:return: a pyList containing all nodename/presetname pairs."
    },
    {
        "name": "hotkeys",
        "type": "Function",
        "doc": "hotkeys() -> str\n\nReturns the Nuke key assignments as a string formatted for use in nuke.display().\n\n:return: A formatted string."
    },
    {
        "name": "inputs",
        "type": "Function",
        "doc": "inputs(n, i) -> int\n\nDeprecated. Use Node.inputs.\n\nGet how many inputs the node has. Normally this is a constant but some nodes have a variable number, the user can keep connecting them and the count will increase.\nAttempting to set the number will just disconnect all inputs greater or equal to number. For a variable input node this may decrease\ninputs to the new value. For most nodes this will have no effect on the value of inputs.\n\n:param n: Node.\n:param i: Optional number of inputs requested.\n:return: Number of inputs."
    },
    {
        "name": "invertSelection",
        "type": "Function",
        "doc": "invertSelection() -> None\n\nSelects all unselected nodes, and deselects all selected ones.\n\n:return: None."
    },
    {
        "name": "knob",
        "type": "Function",
        "doc": "knob(name, value, getType, getClass) -> None\n\nReturns or sets the entire state of a knob.\n\nEach individual control on a control panel is called a 'knob'. A\nknob's name is a dot-separated list. An example of a fully-expanded\nname of a knob is 'root.Group1.Blur1.size.w'. 'root' is the node\nname of the outermost group, 'Group1' is a group inside that\ncontaining the blur operator, 'Blur1' is the name of a blur\noperator, 'size' is the name of the actual knob, and 'w' is the\nname of the 'field' (there are two fields in a blur size, 'w' and\n'h').\n\nYou can omit a lot of this because all knob names are figured out\nrelative to a 'current knob' and 'current node'. These are set\ndepending on the context of where the scripting is invoked. For\nmenu items the current node is the group that contained the menu,\nand there is no current knob. For expressions typed into knob\nfields the current knob is that knob and the current node is the\nnode the knob belongs to.\n\nIf a name does not start with 'root' then a search upwards is done\nfor the first word in the name, first against the fields in the\ncurrent knob, then against the knobs in the current node, then\nagainst the nodes in the group containing the current node (or in\nit if it is a group), on up to the root.\n\nThe word 'this' means the current knob or the current node.\n\nThe word 'input' means the first (0 or B) input of a node. Ie\n'Blur1.input' returns the node connected to the input of Blur1,\nwhile 'Blur1.input.input' returns the input of that node.\n\nIf you are getting the value for reporting to the user, you probably\nwant to use the value or expression commands.\n\nIf the getType argument is specified and is True, it will print out the type of the\nknob rather than getting or setting the value. The type is an integer,\nusing the same list as addUserKnob.\n\nIf the getClass argument is specified and is True, it will print out the type of the knob as a string, e.g. 'Int_Knob',\n'Enumeration_Knob', 'XY_Knob'.\n\nIf both the getType and getClass arguments are present and are True, getType takes precedence.\n\n:param name: The name of the knob.\n:param value: Optional argument. If this is present, the value will be stored into the knob.\n:param getType: Optional boolean argument. If True, return the class ID for the knob instead of the knob itself. The class ID is an int.\n:param getClass: Optional boolean argument. If True, return the class name for the knob instead of the knob itself. The class name is a string."
    },
    {
        "name": "knobChanged",
        "type": "Function",
        "doc": "No documentation available."
    },
    {
        "name": "knobDefault",
        "type": "Function",
        "doc": "knobDefault(classknob, value) -> str\n\nSet a default value for knobs in nodes that belong to the\nsame class. All knobs with matching names, that are created after this\ncommand was issued, will default to the new value. If class. is missing\nor is \\*.\\ then this default applies to all nodes with such a knob.\nIf several values are supplied, the first value which is valid will be\nused as the default.\nknobDefault can be used to specify file format specific knobs.\nThese are knobs that are added to Read, Write and other file format\ndependent nodes when the file name changes. To specify defaults, use\nthe class name, followed by the file format extension, followed by the knob name,\nall separated by periods. An example is shown below.\n\nExample:\n  nuke.knobDefault(Blur.size, 20)\n\nExample:\n  nuke.knobDefault(Read.exr.compression, 2)\n\n:param classknob: String in the form `class.knob` where `class` is the class of Node, i.e. Blur, and \\knob\\ is the name of the knob. This can also include a file extension, as in \\class.extension.knob\\\n:param value: Optional string to convert to the default value.\n:return: None or String with the default value."
    },
    {
        "name": "knobTooltip",
        "type": "Function",
        "doc": "knobTooltip(classknob, value) -> None\n\nSet an override for a tooltip on a knob.\n\nExample:\n\n   nuke.knobTooltip('Blur.size', '[some text]')\n\n:param classknob: String in the form `class.knob` where `class` is the class of Node, i.e. Blur, and \\knob\\ is the name of the knob.\n:param value: String to use as the tooltip\n:return: None)"
    },
    {
        "name": "layers",
        "type": "Function",
        "doc": "layers(node=None) -> string list.\n\nLists the layers in a node. If no node is provided this will list all known\nlayer names in this script.\n\n:param node: Optional node parameter.\n:return: A list of layer names."
    },
    {
        "name": "licenseInfo",
        "type": "Function",
        "doc": "licenseInfo() -> Shows information about licenses used by nuke.\n\n:return: None"
    },
    {
        "name": "load",
        "type": "Function",
        "doc": "load(s) -> None\n\nLoad a plugin. You can force a certain plugin to load with this function. If the plugin has already been loaded nothing happens.\nIf there is no slash in the name then the pluginPath() is searched for it. If there is a slash then the name is used directly as a\nfilename, if it does not start with a slash the name is relative to the directory containing any plugin being currently loaded.\nIf no filename extension is provided, it will try appending '.so' (or whatever your OS dynamic library extension is) and finding\nnothing will also try to append '.tcl' and '.py'.\n\n:param s: Plugin name or filename.\n:return: None\n:raise RuntimeError: if the plugin couldn't be loaded for any reason."
    },
    {
        "name": "loadModuleFromPath",
        "type": "Function",
        "doc": " Load a Python file and return the module object "
    },
    {
        "name": "loadToolset",
        "type": "Function",
        "doc": "loadToolset(filename=None, overwrite=-1) -> None\n\nLoads the tool preset with the given file name.\n\n:param filename: name of preset script file to load"
    },
    {
        "name": "localiseFiles",
        "type": "Function",
        "doc": "localiseFiles(readKnobs)\n\n**This functionality has been removed, please check the documentation**\n\n@return: None."
    },
    {
        "name": "localizationEnabled",
        "type": "Function",
        "doc": "localizationEnabled(knob) -> bool\n\nChecks if localization is enabled on a given Read_File_Knob.\n\n:param knob: The Read_File_Knob to check.\n:return: true if enabled, false otherwise"
    },
    {
        "name": "makeGroup",
        "type": "Function",
        "doc": "makeGroup(show=True) -> Group\n\nCreates a new group containing copies of all the currently selected nodes.\nNote that this creates duplicates of the selected nodes, rather than moving\nthem.\n\n:param show: If show is True, the node graph for the new group is shown.\n:return: The new Group node."
    },
    {
        "name": "maxPerformanceInfo",
        "type": "Function",
        "doc": "maxPerformanceInfo -> Get the max performance info for this session.\n\n:return: a struct containing the max performance info if performance timers are in use, otherwise returns None."
    },
    {
        "name": "menu",
        "type": "Function",
        "doc": "menu(name) -> Menu\n\nFind and return the Menu object with the given name.\n\n:param name: The name of the menu to get. Must be on the following values:\n  - 'Nuke': The application menu\n  - 'Pane': The UI Panes & Panels menu\n  - 'Nodes': The Nodes toolbar (and Nodegraph right mouse menu)\n  - 'Properties': The Properties panel right mouse menu\n  - 'Animation': The knob Animation menu and Curve Editor right mouse menu\n  - 'Viewer': The Viewer right mouse menu\n  - 'Node Graph': The Node Graph right mouse menu\n  - 'Axis': Functions which appear in menus on all Axis_Knobs.\n\n:return: The menu.\n:raises: RuntimeError: if Nuke isn't in GUI mode."
    },
    {
        "name": "message",
        "type": "Function",
        "doc": "message(prompt) -> None\n\nShow an info dialog box. Pops up an info box (with a 'i' and the text\nmessage) and waits for the user to hit the OK button.\n\n:param prompt: Present user with this message.\n:return: None"
    },
    {
        "name": "modified",
        "type": "Function",
        "doc": "modified(status) -> True if modified, False otherwise.\n\nDeprecated. Use Root.modified and Root.setModified.\n\nGet or set the 'modified' flag in a script. Setting the value will turn the\nindicator in the title bar on/off and will start or stop the autosave timeout.\n\n:param status: Optional boolean value. If this is present the status will be set to this value; otherwise it will be retrieved instead.\n:return: True if modified, False otherwise."
    },
    {
        "name": "nodeAtPath",
        "type": "Function",
        "doc": "nodeAtPath(path, instanceIndex) -> Node\n\nFind the node at the given full path, if it exists, and return it as a Python object.\nIf the 'instanceIndex' provided is >= 0 then a specific clone instance (index 1+), or\nthe 'original'(base) instance (index 0) is returned. If 'instanceIndex' value is not\nvalid for the retrieved Node's context then null is returned.\n\n'path' is -always- an absolute path and periods '.' are assumed as the node hierarchy\nseparator, conforming to the standard Nuke node path convention. However unlike 'toNode()'\nembedded expressions are -NOT- supported in the path string. For example you cannot\nretrieve a node using the path string 'Group1.FooNode.parent' as the trailing '.parent'\nis an expression, while 'Group1.FooNode' will work since it ends in an explicit node name.\n\n:param path: Absolute node path ending in a node name. No expression support provided.\n:param instanceIndex: Optional. If >= 0 return a specific clone instance where index 0 is the\nbase node and index 1+ are clones. If instanceIndex is specified but the node is not cloned\nor the value is out of range then None is returned.\n:return: Node or None if it does not exist.\n"
    },
    {
        "name": "nodeCopy",
        "type": "Function",
        "doc": "nodeCopy(s) -> bool\n\nCopy all selected nodes into a file or the clipboard.\n\n:param s: The name of a clipboad to copy into. If s is the string '%clipboard%' this will copy into the operating systems clipboard.\n:return: True if any nodes were selected, False otherwise."
    },
    {
        "name": "nodeDelete",
        "type": "Function",
        "doc": "nodeDelete(s) -> True if any nodes were deleted, False otherwise.\n\nRemoves all selected nodes from the DAG.\n\n:return: True if all nodes were deleted, False if at least one wasn't."
    },
    {
        "name": "nodePaste",
        "type": "Function",
        "doc": "nodePaste(s) -> Node\n\nPaste nodes from a script file or the clipboard.\nThis function executes the script stored in a file. It is assumed the script is the result of\na nodeCopy command. The 's' argument can be '%clipboard%' to paste the operating system's clipboard contents.\n\n:param s: The 's' argument can be '%clipboard%' to paste the operating system's clipboard contents.\n:return: Node"
    },
    {
        "name": "nodeTypes",
        "type": "Function",
        "doc": "nodeTypes(force_plugin_load=False) -> List\n\n:param force_plugin_load bool True to force loading all plugins on the path before querying node types, defaults to False\n:return list of all loaded node types"
    },
    {
        "name": "nodesSelected",
        "type": "Function",
        "doc": "nodesSelected() -> None\n\n:return: true if any nodes are currently selected"
    },
    {
        "name": "numvalue",
        "type": "Function",
        "doc": "numvalue(knob, default=infinity) -> float\n\nThe numvalue function returns the current value of a knob.\n\nThis is the same as the value() command except it will always return a\nnumber. For enumerations this returns the index into the menu, starting at\nzero. For checkmarks this returns 0 for false and 1 for true.\n\n:param knob: A knob.\n:param default: Optional default value to return if the knob's value cannot\n be converted to a number.\n:return: A numeric value for the knob, or the default value (if any)."
    },
    {
        "name": "oculaPresent",
        "type": "Function",
        "doc": "oculaPresent() -> bool\n\nCheck whether Ocula is present.\n\n:return: True if Ocula is present, False if not."
    },
    {
        "name": "ofxAddPluginAliasExclusion",
        "type": "Function",
        "doc": "ofxAddPluginAliasExclusion(fullOfxEffectName) -> None\n\nAdds the ofx effect name to a list of exclusions that will not get tcl aliases automatically created for them.\n\nFor example, if there is an ofx plugin with a fully qualified name of: 'OFXuk.co.thefoundry.noisetools.denoise_v100'.\n\nNuke by default would automatically alias that so that nuke.createNode('Denoise') will create that node type.\n\nBy calling nuke.ofxAddPluginAliasExclusion('OFXuk.co.thefoundry.noisetools.denoise_v100'), you'd be changing\nthat such that the only way to create a node of that type would be to call nuke.createNode('OFXuk.co.thefoundry.noisetools.denoise_v100')\nThis does not change saving or loading of Nuke scripts with that plugin used in any way.\n\n:param fullOfxEffectName: The fully qualified name of the ofx plugin to add to the exclusion list.\n:return: None."
    },
    {
        "name": "ofxMenu",
        "type": "Function",
        "doc": "ofxMenu() -> bool\n\nFind all the OFX plugins (by searching all the directories below $OFX_PLUGIN_PATH,\nor by reading a cache file stored in $NUKE_TEMP_DIR), then add a menu item for each\nof them to the main menu.\n\n:return: True if succeeded, False otherwise."
    },
    {
        "name": "ofxPluginPath",
        "type": "Function",
        "doc": "nuke.ofxPluginPath() -> String list\n\nList of all the directories Nuke searched for OFX plugins in.\n\n:return: String list"
    },
    {
        "name": "ofxRemovePluginAliasExclusion",
        "type": "Function",
        "doc": "ofxRemovePluginAliasExclusion(fullOfxEffectName) -> None\n\nRemove an ofx plugin alias exclusion that was previously added with .\nExample: nuke.ofxRemovePluginAliasExclusion('OFXuk.co.thefoundry.noisetools.denoise_v100')\n\n:param fullOfxEffectName: The fully qualified name of the ofx plugin to remove from the exclusion list.\n:return: None."
    },
    {
        "name": "onCreate",
        "type": "Function",
        "doc": "No documentation available."
    },
    {
        "name": "onDestroy",
        "type": "Function",
        "doc": "No documentation available."
    },
    {
        "name": "onScriptClose",
        "type": "Function",
        "doc": "No documentation available."
    },
    {
        "name": "onScriptLoad",
        "type": "Function",
        "doc": "No documentation available."
    },
    {
        "name": "onScriptSave",
        "type": "Function",
        "doc": "No documentation available."
    },
    {
        "name": "onUserCreate",
        "type": "Function",
        "doc": "No documentation available."
    },
    {
        "name": "openPanels",
        "type": "Function",
        "doc": "nodesSelected() -> List\n\n:return: a list of Nodes which have panels open. The last item in the list is the currently active Node panel."
    },
    {
        "name": "pan",
        "type": "Function",
        "doc": "pan() -> array with x, then y\n\nReturn the pan values of a group's display.\nThis function is deprecated and will be removed in a future version.  You probably want to use nuke.center().\\n\nn = nuke.pan()\nprint n[0]\nprint n[1]\n\n:return: Array of x, y."
    },
    {
        "name": "performanceProfileFilename",
        "type": "Function",
        "doc": "performanceProfileFilename() -> File to write performance profile to for this session.\n\n:return: the profile filename if performance timers are in use, otherwise returns None."
    },
    {
        "name": "pluginAddPath",
        "type": "Function",
        "doc": " Adds all the paths to the beginning of the Nuke plugin path.\n      If the path already exists in the list of plugin paths, it is moved\n      to the start. If this command is executed inside an init.py then\n      the init.py in the path will be executed.\n      It also adds the paths to the sys.path, if addToSysPath is True."
    },
    {
        "name": "pluginAppendPath",
        "type": "Function",
        "doc": " Add a filepath to the end of the Nuke plugin path.  If the path\n      already exists in the list of plugin paths, it will remain at its\n      current position.\n      It also appends the paths to the sys.path, if addToSysPath is True."
    },
    {
        "name": "pluginExists",
        "type": "Function",
        "doc": "pluginExists(name) -> True if found, or False if not.\n\nThis function is the same as load(), but only checks for the existence of a plugin rather than loading it.\nIf there is no slash in the name then the pluginPath() is searched for it. If there is a slash then the name is used directly as a\nfilename, if it does not start with a slash the name is relative to the directory containing any plugin being currently loaded.\nIf no filename extension is provided, it will try appending '.so' (or whatever your OS dynamic library extension is) and finding\nnothing will also try to append '.tcl' and '.py'.\n\n:param name: Plugin name or filename.\n:return: True if found, or False if not."
    },
    {
        "name": "pluginInstallLocation",
        "type": "Function",
        "doc": "pluginInstallLocation() -> string list\n\nThe system-specific locations that Nuke will look in for third-party plugins.\n\n:return: List of paths."
    },
    {
        "name": "pluginPath",
        "type": "Function",
        "doc": "pluginPath() -> string list\n\nList all the directories Nuke will search in for plugins.\n\nThe built-in default is ~/.nuke and the 'plugins' directory from the\nsame location the NUKE executable file is in. Setting the environment\nvariable $NUKE_PATH to a colon-separated list of directories will\nreplace the ~/.nuke with your own set of directories, but the plugins\ndirectory is always on the end.\n\n:return: List of paths."
    },
    {
        "name": "plugins",
        "type": "Function",
        "doc": "plugins(switches=0, *pattern)-> list of str\n\nReturns a list of every loaded plugin or every plugin available. By\ndefault each plugin is returned as the full pathname of the plugin\nfile.\n\nYou can give a glob-style matching pattern and only the plugins\nwhose filenames (not path) match the pattern will be returned. You can\ngive more than one glob pattern if desired.\n\nYou can also put options before the glob patterns. Currently supported:\n\n  ALL    Return all plugins in each of the plugin_path() directories,\n         rather than only the currently loaded plugins.\n\n  NODIR  Just put the filenames in the list, not the full path. There\n         may be duplicates.\n\n  REGISTERED  Include Ops which have been registered by the loaded plugins.\n              This is useful for plugin bundles where there are registered Ops\n              which do not have their own plugin file.\n              Please note that these Ops will not have a directory path or\n              file extension.  They are not filtered by the pattern.\n\n  NOREADERWRITER  Do not include Reader or Writer plugins.  These cannot be used\n                  as stand-alone plugins.\n\nIf you don't specify any switches, the default behaviour is to return a list\nwith the full paths of all loaded plugins.\n\n:param switches: Optional parameter. Bitwise OR of nuke.ALL, nuke.NODIR,\n                 nuke.REGISTERED, nuke.NOREADERWRITER.\n:param pattern: Zero or more glob patterns.\n:return: List of plugins.\n"
    },
    {
        "name": "recentFile",
        "type": "Function",
        "doc": "recentFile(index) -> str\n\nReturns a filename from the recent-files list.\n\n:param index: A position in the recent files list. This must be a non-negative number.\n:return: A file path.\n:raise ValueError: if the index is negative.\n:raise RuntimeError: if there is no entry in the recent files list for the specified index."
    },
    {
        "name": "redo",
        "type": "Function",
        "doc": "redo() -> None\n\nPerform the most recent redo.\n\n:return: None"
    },
    {
        "name": "registerFlipbook",
        "type": "Function",
        "doc": "registerFlipbook(s) -> None\n\nRegister a flipbook application name into Nuke.\n\n:param s: Name of the flipbook application to be registered.\n:return: None"
    },
    {
        "name": "removeAfterBackgroundFrameRender",
        "type": "Function",
        "doc": "Remove a previously-added callback with the same arguments."
    },
    {
        "name": "removeAfterBackgroundRender",
        "type": "Function",
        "doc": "Remove a previously-added callback with the same arguments."
    },
    {
        "name": "removeAfterFrameRender",
        "type": "Function",
        "doc": "Remove a previously-added callback with the same arguments."
    },
    {
        "name": "removeAfterRecording",
        "type": "Function",
        "doc": "Remove a previously-added callback with the same arguments."
    },
    {
        "name": "removeAfterRender",
        "type": "Function",
        "doc": "Remove a previously-added callback with the same arguments."
    },
    {
        "name": "removeAfterReplay",
        "type": "Function",
        "doc": "Remove a previously-added callback with the same arguments."
    },
    {
        "name": "removeAutoSaveDeleteFilter",
        "type": "Function",
        "doc": "Remove a previously-added callback with the same arguments."
    },
    {
        "name": "removeAutoSaveFilter",
        "type": "Function",
        "doc": "Remove a previously-added callback with the same arguments."
    },
    {
        "name": "removeAutoSaveRestoreFilter",
        "type": "Function",
        "doc": "Remove a previously-added callback with the same arguments."
    },
    {
        "name": "removeAutolabel",
        "type": "Function",
        "doc": "Remove a previously-added callback with the same arguments."
    },
    {
        "name": "removeBeforeBackgroundRender",
        "type": "Function",
        "doc": "Remove a previously-added callback with the same arguments."
    },
    {
        "name": "removeBeforeFrameRender",
        "type": "Function",
        "doc": "Remove a previously-added callback with the same arguments."
    },
    {
        "name": "removeBeforeRecording",
        "type": "Function",
        "doc": "Remove a previously-added callback with the same arguments."
    },
    {
        "name": "removeBeforeRender",
        "type": "Function",
        "doc": "Remove a previously-added callback with the same arguments."
    },
    {
        "name": "removeBeforeReplay",
        "type": "Function",
        "doc": "Remove a previously-added callback with the same arguments."
    },
    {
        "name": "removeDefaultColorspaceMapper",
        "type": "Function",
        "doc": "\n  Remove a previously-added callback with the same arguments.\n  "
    },
    {
        "name": "removeFavoriteDir",
        "type": "Function",
        "doc": "removeFavoriteDir(name, type) -> None.\n\nRemove a directory path from the favorites list.\n\n:param name: Favourite path entry ('Home', 'Desktop', etc.).\n:param type: Optional bitwise OR combination of nuke.IMAGE, nuke.SCRIPT, nuke.FONT or nuke.GEO.\n:return: None"
    },
    {
        "name": "removeFilenameFilter",
        "type": "Function",
        "doc": "Remove a previously-added callback with the same arguments."
    },
    {
        "name": "removeFilenameValidate",
        "type": "Function",
        "doc": "Remove a previously-added callback."
    },
    {
        "name": "removeKnobChanged",
        "type": "Function",
        "doc": "Remove a previously-added callback with the same arguments."
    },
    {
        "name": "removeOnCreate",
        "type": "Function",
        "doc": "Remove a previously-added callback with the same arguments."
    },
    {
        "name": "removeOnDestroy",
        "type": "Function",
        "doc": "Remove a previously-added callback with the same arguments."
    },
    {
        "name": "removeOnScriptClose",
        "type": "Function",
        "doc": "Remove a previously-added callback with the same arguments."
    },
    {
        "name": "removeOnScriptLoad",
        "type": "Function",
        "doc": "Remove a previously-added callback with the same arguments."
    },
    {
        "name": "removeOnScriptSave",
        "type": "Function",
        "doc": "Remove a previously-added callback with the same arguments."
    },
    {
        "name": "removeOnUserCreate",
        "type": "Function",
        "doc": "Remove a previously-added callback with the same arguments."
    },
    {
        "name": "removeRenderProgress",
        "type": "Function",
        "doc": "Remove a previously-added callback with the same arguments."
    },
    {
        "name": "removeUpdateUI",
        "type": "Function",
        "doc": "Remove a previously-added callback with the same arguments."
    },
    {
        "name": "render",
        "type": "Function",
        "doc": "execute(nameOrNode, start, end, incr, views, continueOnError = False) -> None.\nexecute(nameOrNode, frameRangeSet, views, continueOnError = False) -> None.\\n\n\nExecute the named Write node over the specified frames.\n\nThere are two variants of this function. The first allows you to specify the\nframes to write range by giving the start frame number, the end frame number\nand the frame increment. The second allows you to specify more complicated\nsets of frames by providing a sequence of FrameRange objects.\n\nIf Nuke is run with the GUI up, this will pop up a progress meter. If the user hits\nthe cancel button this command will return 'cancelled' error.\nIf Nuke is run from the nuke command line (ie nuke was started with the -t switch)\nexecute() prints a text percentage as it progresses.\nIf the user types ^C it will aborting the execute() and return a 'cancelled' error.\n\n:param nameOrNode: A node name or a node object.\n:param start: Optional start frame. Default is root.first_frame.\n:param end: Optional end frame. Default is root.last_frame.\n:param incr: Optional increment. Default is 1.\n:param views: Optional list of views. Default is None, meaning \\all views\\.\n:return: None"
    },
    {
        "name": "renderProgress",
        "type": "Function",
        "doc": "No documentation available."
    },
    {
        "name": "rescanFontFolders",
        "type": "Function",
        "doc": "rescanFontFolders() -> None\n\nRebuild the font cache scanning all available font directories.\n\n:return: None."
    },
    {
        "name": "resetPerformanceTimers",
        "type": "Function",
        "doc": "resetPerformanceTimers() -> None\n\nClears the accumulated time on the performance timers."
    },
    {
        "name": "restoreWindowLayout",
        "type": "Function",
        "doc": "restoreWindowLayout(i) -> None.\n\nRestores a saved window layout.\n\n:param i: Layout number\n:return: None\n\nWARNING - DEPRECATED ( nuke.restoreWindowLayout ): \nThis method is deprecated. The Restore action in the Workspace Menu corresponding to the input argument will be triggered.\nhiero.ui.setWorkspace(name) should be called with the desired workspace name."
    },
    {
        "name": "resumePathProcessing",
        "type": "Function",
        "doc": "resumePathProcessing() -> None\n\nResume path processing.\nUse prior to performingmultiple node graph modifications, to avoid repeated path processing.\n\n:return: None."
    },
    {
        "name": "root",
        "type": "Function",
        "doc": "root() -> node\n\nGet the DAG's root node. Always succeeds.\n\n:return: The root node. This will never be None."
    },
    {
        "name": "runIn",
        "type": "Function",
        "doc": "runIn(object, cmd) -> bool\n\nExecute commands with a given node/knob/field as the 'context'.\nThis means that all names are evaluated relative to this object, and commands that modify 'this' node will modify the given one.\n\n:param object: Name of object.\n:param cmd: Command to run.\n:return: True if succeeded, False otherwise."
    },
    {
        "name": "sample",
        "type": "Function",
        "doc": "sample(n, c, x, y, dx, dy) -> float.\n\nGet pixel values from an image. Deprecated, use Node.sample instead.\n\nThis requires the image to be calculated, so performance may be very bad if this is placed into an expression in\na control panel. Produces a cubic filtered result. Any sizes less than 1, including 0, produce the same filtered result,\nthis is correct based on sampling theory. Note that integers are at the corners of pixels, to center on a pixel add .5 to both coordinates.\nIf the optional dx,dy are not given then the exact value of the square pixel that x,y lands in is returned. This is also called 'impulse filtering'.\n\n:param n: Node.\n:param c: Channel name.\n:param x: Centre of the area to sample (X coordinate).\n:param y: Centre of the area to sample (Y coordinate).\n:param dx: Optional size of the area to sample (X coordinate).\n:param dy: Optional size of the area to sample (Y coordinate).\n:return: Floating point value."
    },
    {
        "name": "saveEventGraphTimers",
        "type": "Function",
        "doc": "saveEventGraphTimers(filePath) -> None\n\nSave events in the event graph.\n\n:param filePath: specify the file path where the event graph profiling data should be saved to."
    },
    {
        "name": "saveToScript",
        "type": "Function",
        "doc": "saveToScript(filename, fileContent) -> None\n\nSaves the fileContent with the given filename."
    },
    {
        "name": "saveUserPreset",
        "type": "Function",
        "doc": "saveUserPreset(node, presetName) -> None\n\nSaves a node's current knob values as a user preset.\n\n:param presetName: Name of the preset to create.\n:return: bool."
    },
    {
        "name": "saveWindowLayout",
        "type": "Function",
        "doc": "saveWindowLayout(i=-1) -> None\n\nSaves the current window layout.\n\n:param i: Optional layout index. If this is omitted or set to a negative value, save as the default layout.\n:return: None.\n\nWARNING - DEPRECATED ( nuke.saveWindowLayout ): \nThis method is deprecared. The Save action in the Workspace Menu corresponding to the input argument will be triggered.\nhiero.ui.saveWorkspace(name) should be called with the new workspace name."
    },
    {
        "name": "scriptClear",
        "type": "Function",
        "doc": "Clears a Nuke script and resets all the root knobs to user defined knob defaults. To reset to compiled in defaults only pass in resetToCompiledDefaults=True. To clear the user knobs, pass in clearUserKnobs=True."
    },
    {
        "name": "scriptClose",
        "type": "Function",
        "doc": " scriptSaveAndClear(filename=None, ignoreUnsavedChanges=False) -> None\n  Calls nuke.scriptSave and nuke.scriptClear\n  @param filename: Save to this file name without changing the script name in the\n   project.\n  @param ignoreUnsavedChanges: Optional. If set to True scripSave will be called,\n   ignoring any unsaved changes\n  @return: True when sucessful. False if the user cancels the operation. In this\n   case nuke.scripClear will not be called\n   "
    },
    {
        "name": "scriptExit",
        "type": "Function",
        "doc": "Exit the Application if 'forceExit' is True, otherwise 'nuke.scriptSaveAndClear' will be called\n  @param forceExit: Optional parameter. Forces the Application to close.\n  @return: None."
    },
    {
        "name": "scriptName",
        "type": "Function",
        "doc": "scriptName() -> String\n\nReturn the current script's file name"
    },
    {
        "name": "scriptNew",
        "type": "Function",
        "doc": "Start a new script. Returns True if successful."
    },
    {
        "name": "scriptOpen",
        "type": "Function",
        "doc": "Opens a new script containing the contents of the named file."
    },
    {
        "name": "scriptReadFile",
        "type": "Function",
        "doc": "Read nodes from a file."
    },
    {
        "name": "scriptReadText",
        "type": "Function",
        "doc": "Read nodes from a string."
    },
    {
        "name": "scriptSave",
        "type": "Function",
        "doc": "scriptSave(filename=None) -> bool\n\nSaves the current script to the current file name. If there is no current\nfile name and Nuke is running in GUI mode, the user is asked for a name using\nthe file chooser.\n\n:param filename: Save to this file name without changing the script name in the project (use scriptSaveAs() if you want it to change).\n:return: True if the file was saved, otherwise an exception is thrown.)"
    },
    {
        "name": "scriptSaveAndClear",
        "type": "Function",
        "doc": " scriptSaveAndClear(filename=None, ignoreUnsavedChanges=False) -> None\n  Calls nuke.scriptSave and nuke.scriptClear\n  @param filename: Save to this file name without changing the script name in the\n   project.\n  @param ignoreUnsavedChanges: Optional. If set to True scripSave will be called,\n   ignoring any unsaved changes\n  @return: True when sucessful. False if the user cancels the operation. In this\n   case nuke.scripClear will not be called\n   "
    },
    {
        "name": "scriptSaveAs",
        "type": "Function",
        "doc": "scriptSaveAs(filename=None, overwrite=-1) -> None\n\nSaves the current script with the given file name if supplied, or (in GUI\nmode) asks the user for one using the file chooser. If Nuke is not running\nin GUI mode, you must supply a filename.\n\n:param filename: Saves the current script with the given file name if\n supplied, or (in GUI mode) asks the user for one using the file chooser.\n:param overwrite: If 1 (true) always overwrite; if 0 (false) never overwrite;\n otherwise, in GUI mode ask the user, in terminal do same as False. Default\n is -1, meaning 'ask the user'."
    },
    {
        "name": "scriptSaveToTemp",
        "type": "Function",
        "doc": "scriptSaveToTemp(string) -> string\n\nSaves the script to a file without modifying the root information or the original script\n\n:param overwrite: Optional boolean to overwrite an existing file. If not specified, the behaviour defaults to False.\n:return: string"
    },
    {
        "name": "scriptSource",
        "type": "Function",
        "doc": "Same as scriptReadFile()."
    },
    {
        "name": "script_directory",
        "type": "Function",
        "doc": "No documentation available."
    },
    {
        "name": "selectAll",
        "type": "Function",
        "doc": "selectAll() -> None\n\nSelect all nodes in the DAG.\n\n:return: None"
    },
    {
        "name": "selectConnectedNodes",
        "type": "Function",
        "doc": " Selects all nodes in the tree of the selected node. "
    },
    {
        "name": "selectPattern",
        "type": "Function",
        "doc": "selectPattern() -> None\n\nSelects nodes according to a regular expression matching pattern, entered\nthrough an input dialog. The pattern can include wildcards ('?' and '*') as\nwell as regular expressions. The expressions are checked against the node\nname, label, class, and associated file names.\n\n:return: None"
    },
    {
        "name": "selectSimilar",
        "type": "Function",
        "doc": "selectSimilar(matchType) -> None\n\nSelects nodes that match a node in the current selection based on matchType criteria.\n\n:param matchType: One of nuke.MATCH_CLASS, nuke.MATCH_LABEL, nuke.MATCH_COLOR.\n:return: None."
    },
    {
        "name": "selectedNode",
        "type": "Function",
        "doc": "selectedNode() -> Node.\n\nReturns the 'node the user is thinking about'.\nIf several nodes are selected, this returns one of them. The one returned will be an 'output' node in that no other selected nodes\nuse that node as an input. If no nodes are selected, then if the last thing typed was a hotkey this returns the node the cursor is pointing at.\nIf none, or the last event was not a hotkey, this produces a 'No node selected' error.\n\n:return: Node."
    },
    {
        "name": "selectedNodes",
        "type": "Function",
        "doc": "selectedNodes(filter) -> List.\n\nReturns a list of all selected nodes in the current group. An attempt is made to return them in 'useful' order\nwhere inputs are done before the final node, so commands applied to this list go from top-down.\n\n:param filter: Optional class of Node. Instructs the algorithm to apply only to a specific class of nodes.\n:return: The list of selected nodes."
    },
    {
        "name": "setGeoSelection",
        "type": "Function",
        "doc": "setGeoSelection(GeoSelection) -> None\n\nSet the currently selected geometry"
    },
    {
        "name": "setPreset",
        "type": "Function",
        "doc": "setPreset(nodeClassName, presetName, knobValues) -> None\n\nCreate a node preset for the given node using the supplied knob values\n\n:param nodeClassName: Name of the node class to create a preset for.\n:param presetName: Name of the preset to create.\n:param knobValues: A dictionary containing a set of knob names and preset values.\n:return: bool."
    },
    {
        "name": "setReadOnlyPresets",
        "type": "Function",
        "doc": "setReadOnlyPresets(readOnly) -> None\n\nSets whether newly created presets should be added in read-only mode.\nRead-only presets can be applied to a node, but can't be overwritten or deleted."
    },
    {
        "name": "setUserPreset",
        "type": "Function",
        "doc": "setUserPreset(nodeClassName, presetName, knobValues) -> None\n\nCreate a node preset for the given node using the supplied knob values\n\n:param nodeClassName: Name of the node class to create a preset for.\n:param presetName: Name of the preset to create.\n:param knobValues: A dictionary containing a set of knob names and preset values.\n:return: bool."
    },
    {
        "name": "show",
        "type": "Function",
        "doc": "show(n, forceFloat) -> None\n\nOpens a window for each named node, as though the user double-clicked on them.  For normal operators this opens the\ncontrol panel, for viewers it opens the viewer, for groups it opens the control panel.\n\n:param n: Optional node argument. Default is the current node.\n:param forceFloat: Optional python object. If it evaluates to True it will open the window as a floating panel. Default is False.\n:return: None"
    },
    {
        "name": "showBookmarkChooser",
        "type": "Function",
        "doc": "showBookmarkChooser(n) -> None\n\nShow bookmark chooser search box.\n\n:return: None"
    },
    {
        "name": "showCreateViewsDialog",
        "type": "Function",
        "doc": "pluginPath() -> string list\n\nList all the directories Nuke will search in for plugins.\n\nThe built-in default is ~/.nuke and the 'plugins' directory from the\nsame location the NUKE executable file is in. Setting the environment\nvariable $NUKE_PATH to a colon-separated list of directories will\nreplace the ~/.nuke with your own set of directories, but the plugins\ndirectory is always on the end.\n\n:return: List of paths."
    },
    {
        "name": "showDag",
        "type": "Function",
        "doc": "showDag(n) -> None\n\nShow the tree view of a group node or opens a node control panel.\n\n:param n: Optional Group.\n:return: None"
    },
    {
        "name": "showInfo",
        "type": "Function",
        "doc": "showInfo(n) -> str\n\nReturns a long string of debugging information about each node and\nthe operators it is currently managing. You should not rely on its\ncontents or format being the same in different versions of Nuke.\n\n:param n: Optional node argument.\n:return: String."
    },
    {
        "name": "showSettings",
        "type": "Function",
        "doc": "showSettings() -> None\n\nShow the settings of the current group.\n\n:return: None"
    },
    {
        "name": "splayNodes",
        "type": "Function",
        "doc": "splayNodes() -> None\n\nDeprecated. Use Group.splaySelectedNodes.\n\n:return: None"
    },
    {
        "name": "startEventGraphTimers",
        "type": "Function",
        "doc": "startEventGraphTimers() -> None\n\nStart keeping track of events in the event graph."
    },
    {
        "name": "startPerformanceTimers",
        "type": "Function",
        "doc": "startPerformanceTimers() -> None\n\nStart keeping track of accumulated time on the performance timers, and display the accumulated time in the DAG."
    },
    {
        "name": "stopEventGraphTimers",
        "type": "Function",
        "doc": "stopEventGraphTimers() -> None\n\nStop keeping track of events in the event graph."
    },
    {
        "name": "stopPerformanceTimers",
        "type": "Function",
        "doc": "stopPerformanceTimers() -> None\n\nStop keeping track of accumulated time on the performance timers, and cease displaying the accumulated time in the DAG."
    },
    {
        "name": "stripFrameRange",
        "type": "Function",
        "doc": "stripFrameRange(clipname) -> string\n\nStrip out the frame range from a clipname, leaving a file path (still possibly with variables).\n\n:param clipname: The clipname.\n:return: The name without the frame range."
    },
    {
        "name": "suspendPathProcessing",
        "type": "Function",
        "doc": "suspendPathProcessing() -> None\n\nSuspend path processing.\nUse prior to performing multiple node graph modifications, to avoid repeated path processing.\n\n:return: None."
    },
    {
        "name": "tabClose",
        "type": "Function",
        "doc": "Close the active dock tab. Returns True if successful."
    },
    {
        "name": "tabNext",
        "type": "Function",
        "doc": "Make the next tab in this dock active. Returns True if successful."
    },
    {
        "name": "tcl",
        "type": "Function",
        "doc": "tcl(s, *args) -> str.\n\nRun a tcl command. The arguments must be strings and passed to\nthe command. If no arguments are given and the command has whitespace in it\nthen it is instead interpreted as a tcl program (this is deprecated).\n\n:param s: TCL code.\n:param args: The arguments to pass in to the TCL code.\n:return: Result of TCL command as string."
    },
    {
        "name": "thisClass",
        "type": "Function",
        "doc": "thisClass() -> None\n\nGet the class name of the current node. This equivalent to calling\nnuke.thisNode().Class(), only faster.\n\n:return: The class name for the current node."
    },
    {
        "name": "thisGroup",
        "type": "Function",
        "doc": "thisGroup() -> Group\n\nReturns the current context Group node.\n\n:return: The group node."
    },
    {
        "name": "thisKnob",
        "type": "Function",
        "doc": "thisKnob() -> Knob\n\nReturns the current context knob if any.\n\n:return: Knob or None"
    },
    {
        "name": "thisNode",
        "type": "Function",
        "doc": "thisNode() -> Node.\n\nReturn the current context node.\n\n:return: The node."
    },
    {
        "name": "thisPane",
        "type": "Function",
        "doc": "thisPane() -> the active pane.\n\nReturns the active pane. This is only valid during a pane menu callback or window layout restoration.\n\n:return: The active pane."
    },
    {
        "name": "thisParent",
        "type": "Function",
        "doc": "thisParent() -> Node\n\nReturns the current context Node parent.\n\n:return: A node."
    },
    {
        "name": "thisRoot",
        "type": "Function",
        "doc": "thisRoot() -> Root\n\nReturns the current context Root node.\n\n:return: The root node."
    },
    {
        "name": "thisView",
        "type": "Function",
        "doc": "thisView() -> str\n\nGet the name of the current view.\n\n:return: The current view name as a string."
    },
    {
        "name": "toNode",
        "type": "Function",
        "doc": "toNode(s) -> Node\n\nSearch for a node in the DAG by name and return it as a Python object.\n\n:param s: Node name.\n:return: Node or None if it does not exist."
    },
    {
        "name": "toggleFullscreen",
        "type": "Function",
        "doc": "toggleFullscreen() -> None\n\nToggles between windowed and fullscreen mode.\n\n:return: None"
    },
    {
        "name": "toggleViewers",
        "type": "Function",
        "doc": "toggleViewers() -> None\n\nToggles all the viewers on and off.\n\n:return: None"
    },
    {
        "name": "toolbar",
        "type": "Function",
        "doc": "toolbar(name, create=True)-> ToolBar\n\nFind and return the ToolBar object with the given name. The name of the\nbuilt-in nodes toolbar is 'Nodes'.\n\n:param name: The name of the toolbar to find or create.\n:param create: Optional parameter. True (the default value) will mean that a new\n toolbar gets created if one with the given name couldn't be found; False will\n mean that no new toolbar will be created.\n:raises: A RuntimeException is thrown if not in GUI mode.\n:return: The toolbar, or None if no toolbar was found and 'create' was False."
    },
    {
        "name": "tprint",
        "type": "Function",
        "doc": "tprint(value, ..., sep=' ', end='\\', file=sys.stdout) -> None\n\nPrints the values to a stream, or to stdout by default.\n\n:param value: A python object\n:param file: a file-like object (stream); defaults to stdout.\n:param sep: string inserted between values, default a space.\n:param end: string appended after the last value, default a newline.\n:return: None"
    },
    {
        "name": "undo",
        "type": "Function",
        "doc": "undo() -> None\n\nPerform the most recent undo.\n\n:return: None"
    },
    {
        "name": "updateUI",
        "type": "Function",
        "doc": "No documentation available."
    },
    {
        "name": "usingOcio",
        "type": "Function",
        "doc": "usingOCIO() -> returns true if using OCIO instead of Nuke LUTs.\n\n:return: bool\n"
    },
    {
        "name": "usingPerformanceTimers",
        "type": "Function",
        "doc": "usingPerformanceTimers() -> True if on, False if off\n\n:return: true if performance timers are in use."
    },
    {
        "name": "validateFilename",
        "type": "Function",
        "doc": "No documentation available."
    },
    {
        "name": "value",
        "type": "Function",
        "doc": "value(knob, default) -> string.\n\nThe value function returns the current value of a knob. The knob argument is a string referring to a knob and default\nis an optional default value to be returned in case of an error. Unlike knob(), this will evaluate animation at the\ncurrent frame, and expand brackets and dollar signs in string knobs."
    },
    {
        "name": "views",
        "type": "Function",
        "doc": "views() -> List.\n\nList of all the globally existing views.\n\n:return: List"
    },
    {
        "name": "waitForThreadsToFinish",
        "type": "Function",
        "doc": "waitForThreadsToFinish() -> str\n\nReturns true if Nuke should wait for any Python threads to finish before exitting.\n\n:return: True or False."
    },
    {
        "name": "warning",
        "type": "Function",
        "doc": "warning(message)-> None\n\nPuts the message into the error console, treating it like a warning.\n\n:param message: String parameter.\n:return: None."
    },
    {
        "name": "zoom",
        "type": "Function",
        "doc": "zoom(scale, center, group) -> float\n\nChange the zoom and pan of a group's display. The scale argument is the new zoom factor.\n//If the group name is omitted then the current group is used. (Not yet implemented.)\nIf the scale is given, but not the center, the zoom is set to that factor and the view is\npositioned so the cursor is pointing at the same place it was before zooming. A zero or negative\nscale value will cause a zoom-to-fit.\n\nIf both scale and center arguments are given, the view is zoomed and then centered on the\nspecified point.\n\nThe new scale factor will be returned, or None if the function is run in a non-GUI context.\n\n:param scale: New zoom factor.\n:param center: Optional 2-item tuple specifying the center coordinates.\n:param group: Optional Group. This is ignored at present.\n:return: Current zoom factor or None if not in a GUI context."
    },
    {
        "name": "zoomToFitSelected",
        "type": "Function",
        "doc": "zoomToFitSelected() -> None\n\nDoes a zoom to fit on the selected nodes in the DAG\n\n:return: None."
    }
]